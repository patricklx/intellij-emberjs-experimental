"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("./util");
const vscode_languageserver_1 = require("vscode-languageserver");
const position_1 = require("./util/position");
const protocol_1 = require("./util/protocol");
class GlintLanguageServer {
    constructor(glintConfig, documents, transformManager, parsedConfig) {
        this.glintConfig = glintConfig;
        this.documents = documents;
        this.transformManager = transformManager;
        this.ts = glintConfig.ts;
        this.openFileNames = new Set();
        this.rootFileNames = new Set(parsedConfig.fileNames);
        let serviceHost = {
            getScriptFileNames: () => [...new Set(this.allKnownFileNames())],
            getScriptVersion: (fileName) => this.documents.getDocumentVersion(fileName),
            getScriptSnapshot: (fileName) => {
                let contents = this.transformManager.readTransformedFile(fileName);
                if (typeof contents === 'string') {
                    return this.ts.ScriptSnapshot.fromString(contents);
                }
            },
            fileExists: this.transformManager.fileExists,
            readFile: this.transformManager.readTransformedFile,
            readDirectory: this.transformManager.readDirectory,
            getCompilationSettings: () => parsedConfig.options,
            // Yes, this looks like a mismatch, but built-in lib declarations don't resolve
            // correctly otherwise, and this is what the TS wiki uses in their code snippet.
            getDefaultLibFileName: this.ts.getDefaultLibFilePath,
            // TS defaults from here down
            getCurrentDirectory: this.ts.sys.getCurrentDirectory,
            directoryExists: this.ts.sys.directoryExists,
            getDirectories: this.ts.sys.getDirectories,
            realpath: this.ts.sys.realpath,
        };
        this.service = this.ts.createLanguageService(serviceHost);
        // Kickstart typechecking
        this.service.getProgram();
    }
    dispose() {
        this.service.dispose();
    }
    openFile(uri, contents) {
        let path = (0, util_1.uriToFilePath)(uri);
        this.documents.updateDocument(path, contents);
        this.openFileNames.add(this.glintConfig.getSynthesizedScriptPathForTS(path));
    }
    updateFile(uri, contents) {
        this.documents.updateDocument((0, util_1.uriToFilePath)(uri), contents);
    }
    closeFile(uri) {
        let path = (0, util_1.uriToFilePath)(uri);
        this.documents.removeDocument(path);
        this.openFileNames.delete(this.glintConfig.getSynthesizedScriptPathForTS(path));
    }
    watchedFileWasAdded(uri) {
        let filePath = (0, util_1.uriToFilePath)(uri);
        if (filePath.startsWith(this.glintConfig.rootDir)) {
            this.rootFileNames.add(this.glintConfig.getSynthesizedScriptPathForTS(filePath));
        }
    }
    watchedFileDidChange(uri) {
        this.documents.markDocumentStale((0, util_1.uriToFilePath)(uri));
    }
    watchedFileWasRemoved(uri) {
        let path = (0, util_1.uriToFilePath)(uri);
        this.documents.markDocumentStale(path);
        // We need to be slightly careful here, because if `foo.ts` and `foo.hbs` both exist and
        // only one is deleted, we shouldn't remove their joint document from `rootFileNames`.
        let companionPath = this.documents.getCompanionDocumentPath(path);
        if (!companionPath || this.glintConfig.getSynthesizedScriptPathForTS(companionPath) !== path) {
            this.rootFileNames.delete(this.glintConfig.getSynthesizedScriptPathForTS(path));
        }
    }
    getDiagnostics(uri) {
        let filePath = (0, util_1.uriToFilePath)(uri);
        let sourcePath = this.findDiagnosticsSource(filePath);
        if (!sourcePath)
            return [];
        let diagnostics = [
            ...this.service.getSyntacticDiagnostics(sourcePath),
            ...this.transformManager.getTransformDiagnostics(sourcePath),
            ...this.service.getSemanticDiagnostics(sourcePath),
            ...this.service.getSuggestionDiagnostics(sourcePath),
        ];
        return this.transformManager
            .rewriteDiagnostics(diagnostics, sourcePath)
            .flatMap((diagnostic) => {
            let { start = 0, length = 0, messageText, file } = diagnostic;
            if (!file || file.fileName !== filePath)
                return [];
            return {
                severity: (0, protocol_1.severityForDiagnostic)(diagnostic),
                message: this.ts.flattenDiagnosticMessageText(messageText, '\n'),
                source: `glint${diagnostic.code ? `:ts(${diagnostic.code})` : ''}`,
                tags: (0, protocol_1.tagsForDiagnostic)(diagnostic),
                range: {
                    start: (0, util_1.offsetToPosition)(file.text, start),
                    end: (0, util_1.offsetToPosition)(file.text, start + length),
                },
            };
        });
    }
    findSymbols(query) {
        return this.service
            .getNavigateToItems(query)
            .map(({ name, kind, fileName, textSpan }) => {
            let location = this.textSpanToLocation(fileName, textSpan);
            if (location) {
                return { name, location, kind: (0, protocol_1.scriptElementKindToSymbolKind)(kind) };
            }
        })
            .filter((info) => Boolean(info));
    }
    getCompletions(uri, position) {
        let { transformedFileName, transformedOffset } = this.getTransformedOffset(uri, position);
        if (this.isTemplate(transformedFileName))
            return;
        let completions = this.service.getCompletionsAtPosition(transformedFileName, transformedOffset, {});
        return completions === null || completions === void 0 ? void 0 : completions.entries.map((completionEntry) => ({
            label: completionEntry.name,
            kind: (0, util_1.scriptElementKindToCompletionItemKind)(completionEntry.kind),
            data: { uri, transformedFileName, transformedOffset, source: completionEntry.source },
        }));
    }
    getCompletionDetails(item) {
        let { label, data } = item;
        if (!data) {
            return item;
        }
        let { transformedFileName, transformedOffset, source } = data;
        let details = this.service.getCompletionEntryDetails(transformedFileName, transformedOffset, label, {}, source, {}, 
        // @ts-ignore: 4.3 adds a new not-optional-but-can-be-undefined `data` arg
        undefined);
        if (!details) {
            return item;
        }
        return {
            ...item,
            detail: this.ts.displayPartsToString(details.displayParts),
            documentation: {
                kind: 'markdown',
                value: this.ts.displayPartsToString(details.documentation),
            },
        };
    }
    prepareRename(uri, position) {
        let { transformedFileName, transformedOffset } = this.getTransformedOffset(uri, position);
        if (this.isTemplate(transformedFileName))
            return;
        let rename = this.service.getRenameInfo(transformedFileName, transformedOffset);
        if (rename.canRename) {
            let { originalStart, originalEnd } = this.transformManager.getOriginalRange(transformedFileName, rename.triggerSpan.start, rename.triggerSpan.start + rename.triggerSpan.length);
            let contents = this.documents.getDocumentContents((0, util_1.uriToFilePath)(uri));
            return {
                start: (0, util_1.offsetToPosition)(contents, originalStart),
                end: (0, util_1.offsetToPosition)(contents, originalEnd),
            };
        }
    }
    getEditsForRename(uri, position, newText) {
        var _a;
        let { transformedFileName, transformedOffset } = this.getTransformedOffset(uri, position);
        if (this.isTemplate(transformedFileName))
            return {};
        let renameLocations = this.service.findRenameLocations(transformedFileName, transformedOffset, false, false);
        if (!(renameLocations === null || renameLocations === void 0 ? void 0 : renameLocations.length)) {
            return {};
        }
        let changes = {};
        for (let { fileName, textSpan } of renameLocations) {
            let { originalFileName, originalStart, originalEnd } = this.transformManager.getOriginalRange(fileName, textSpan.start, textSpan.start + textSpan.length);
            if (originalStart === originalEnd) {
                // Zero-length spans correspond to synthetic use (such as in the context type
                // of the template, which references the containing class), so we want to filter
                // those out.
                continue;
            }
            let originalContents = this.documents.getDocumentContents(originalFileName);
            let originalFileURI = (0, util_1.filePathToUri)(originalFileName);
            let changesForFile = ((_a = changes[originalFileURI]) !== null && _a !== void 0 ? _a : (changes[originalFileURI] = []));
            changesForFile.push({
                newText,
                range: {
                    start: (0, util_1.offsetToPosition)(originalContents, originalStart),
                    end: (0, util_1.offsetToPosition)(originalContents, originalEnd),
                },
            });
        }
        return { changes };
    }
    getHover(uri, position) {
        var _a;
        let { transformedFileName, transformedOffset } = this.getTransformedOffset(uri, position);
        if (this.isTemplate(transformedFileName))
            return;
        let info = this.service.getQuickInfoAtPosition(transformedFileName, transformedOffset);
        if (!info)
            return;
        let value = this.ts.displayPartsToString(info.displayParts);
        let { originalFileName, originalStart, originalEnd } = this.transformManager.getOriginalRange(transformedFileName, info.textSpan.start, info.textSpan.start + info.textSpan.length);
        let originalContents = this.documents.getDocumentContents(originalFileName);
        let start = (0, util_1.offsetToPosition)(originalContents, originalStart);
        let end = (0, util_1.offsetToPosition)(originalContents, originalEnd);
        let contents = [{ language: 'ts', value }];
        if ((_a = info.documentation) === null || _a === void 0 ? void 0 : _a.length) {
            contents.push(this.ts.displayPartsToString(info.documentation));
        }
        return { contents, range: { start, end } };
    }
    getDefinition(uri, position) {
        var _a;
        let { transformedFileName, transformedOffset } = this.getTransformedOffset(uri, position);
        if (this.isTemplate(transformedFileName))
            return [];
        let definitions = (_a = this.service.getDefinitionAtPosition(transformedFileName, transformedOffset)) !== null && _a !== void 0 ? _a : [];
        return this.calculateOriginalLocations(definitions);
    }
    getReferences(uri, position) {
        var _a;
        let { transformedFileName, transformedOffset } = this.getTransformedOffset(uri, position);
        if (this.isTemplate(transformedFileName))
            return [];
        let references = (_a = this.service.getReferencesAtPosition(transformedFileName, transformedOffset)) !== null && _a !== void 0 ? _a : [];
        return this.calculateOriginalLocations(references);
    }
    getTransformedContents(uri) {
        var _a;
        let filePath = (0, util_1.uriToFilePath)(uri);
        let source = this.findDiagnosticsSource(filePath);
        if (source !== filePath)
            return null;
        return (_a = this.transformManager.readTransformedFile(filePath)) !== null && _a !== void 0 ? _a : null;
    }
    calculateOriginalLocations(spans) {
        return spans
            .map((span) => this.textSpanToLocation(span.fileName, span.textSpan))
            .filter((loc) => Boolean(loc));
    }
    textSpanToLocation(fileName, textSpan) {
        let { originalFileName, originalStart, originalEnd } = this.transformManager.getOriginalRange(fileName, textSpan.start, textSpan.start + textSpan.length);
        // If our calculated original span is zero-length but the transformed span
        // does take up space, this corresponds to a synthetic usage we generated
        // in the transformed output, and we don't want to show it to the user.
        if (originalStart === originalEnd && textSpan.length > 0)
            return;
        let originalContents = this.documents.getDocumentContents(originalFileName);
        let start = (0, util_1.offsetToPosition)(originalContents, originalStart);
        let end = (0, util_1.offsetToPosition)(originalContents, originalEnd);
        return vscode_languageserver_1.Location.create((0, util_1.filePathToUri)(originalFileName), { start, end });
    }
    findDiagnosticsSource(fileName) {
        if (!this.isTemplate(fileName)) {
            return this.glintConfig.getSynthesizedScriptPathForTS(fileName);
        }
        if (this.glintConfig.includesFile(fileName)) {
            return this.documents.getCompanionDocumentPath(fileName);
        }
    }
    getTransformedOffset(originalURI, originalPosition) {
        let originalFileName = (0, util_1.uriToFilePath)(originalURI);
        let originalFileContents = this.documents.getDocumentContents(originalFileName);
        let originalOffset = (0, position_1.positionToOffset)(originalFileContents, originalPosition);
        let { transformedOffset, transformedFileName } = this.transformManager.getTransformedOffset(originalFileName, originalOffset);
        return {
            transformedOffset,
            transformedFileName: this.glintConfig.getSynthesizedScriptPathForTS(transformedFileName),
        };
    }
    isTemplate(fileName) {
        return this.glintConfig.environment.isTemplate(fileName);
    }
    *allKnownFileNames() {
        let { environment } = this.glintConfig;
        for (let name of this.rootFileNames) {
            if (environment.isScript(name)) {
                yield name;
            }
        }
        for (let name of this.openFileNames) {
            if (environment.isScript(name)) {
                yield name;
            }
        }
    }
}
exports.default = GlintLanguageServer;
//# sourceMappingURL=glint-language-server.js.map