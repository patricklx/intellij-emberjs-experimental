"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigLoader = void 0;
const path_1 = __importDefault(require("path"));
const silent_error_1 = __importDefault(require("silent-error"));
const resolve_1 = __importDefault(require("resolve"));
const config_1 = require("./config");
/**
 * `ConfigLoader` provides an interface for finding the Glint config that
 * applies to a given file or directory, ensuring that only a single instance
 * of `GlintConfig` is ever created for a given `tsconfig.json` or
 * `jsconfig.json` source file.
 */
class ConfigLoader {
    constructor() {
        this.configs = new Map();
    }
    configForFile(filePath) {
        return this.configForDirectory(path_1.default.dirname(filePath));
    }
    configForDirectory(directory) {
        let ts = findTypeScript(directory);
        if (!ts)
            return null;
        let configPath = findNearestConfigFile(ts, directory);
        if (!configPath)
            return null;
        let existing = this.configs.get(configPath);
        if (existing !== undefined)
            return existing;
        let configInput = loadConfigInput(ts, configPath);
        let config = configInput ? new config_1.GlintConfig(ts, configPath, configInput) : null;
        this.configs.set(configPath, config);
        return config;
    }
}
exports.ConfigLoader = ConfigLoader;
function findTypeScript(fromDir) {
    var _a;
    return ((_a = tryResolve(() => require(resolve_1.default.sync('typescript', { basedir: fromDir })))) !== null && _a !== void 0 ? _a : tryResolve(() => require('typescript')));
}
function tryResolve(load) {
    try {
        return load();
    }
    catch (error) {
        if ((error === null || error === void 0 ? void 0 : error.code) === 'MODULE_NOT_FOUND') {
            return null;
        }
        throw error;
    }
}
function loadConfigInput(ts, entryPath) {
    var _a;
    let fullGlintConfig = {};
    let currentPath = entryPath;
    while (currentPath) {
        let currentContents = ts.readConfigFile(currentPath, ts.sys.readFile).config;
        let currentGlintConfig = (_a = currentContents.glint) !== null && _a !== void 0 ? _a : {};
        assert(currentPath === entryPath || !currentGlintConfig.transform, 'Glint `transform` options may not be specified in extended config.');
        fullGlintConfig = { ...currentGlintConfig, ...fullGlintConfig };
        currentPath =
            currentContents.extends && path_1.default.resolve(path_1.default.dirname(currentPath), currentContents.extends);
    }
    return validateConfigInput(fullGlintConfig);
}
function findNearestConfigFile(ts, searchFrom) {
    // Assume that the longest path is the most relevant one in the case that
    // multiple config files exist at or above our current directory.
    let configCandidates = [
        ts.findConfigFile(searchFrom, ts.sys.fileExists, 'tsconfig.json'),
        ts.findConfigFile(searchFrom, ts.sys.fileExists, 'jsconfig.json'),
    ]
        .filter((path) => typeof path === 'string')
        .sort((a, b) => b.length - a.length);
    return configCandidates[0];
}
function validateConfigInput(input) {
    if (!input['environment'])
        return null;
    assert(Array.isArray(input['environment'])
        ? input['environment'].every((env) => typeof env === 'string')
        : typeof input['environment'] === 'string' ||
            (typeof input['environment'] === 'object' && input['environment']), 'Glint config must specify an `environment` that is a string, array of strings, or an object ' +
        'mapping environment names to their config.');
    assert(input['checkStandaloneTemplates'] === undefined ||
        typeof input['checkStandaloneTemplates'] === 'boolean', 'If defined, `checkStandaloneTemplates` must be a boolean');
    assert(input['transform'] === undefined || isObject(input['transform']), 'If defined, `transform` must be an object');
    let transform = input['transform'];
    if (transform) {
        assert(Array.isArray(transform['include'])
            ? transform['include'].every((item) => typeof item === 'string')
            : !transform['include'] || typeof transform['include'] === 'string', 'If defined, `transform.include` must be a string or array of strings');
        assert(Array.isArray(transform['exclude'])
            ? transform['exclude'].every((item) => typeof item === 'string')
            : !transform['exclude'] || typeof transform['exclude'] === 'string', 'If defined, `transform.exclude` must be a string or array of strings');
    }
    return input;
}
function isObject(value) {
    return typeof value === 'object' && Boolean(value);
}
function assert(test, message) {
    if (!test) {
        throw new silent_error_1.default(`Glint config: ${message}`);
    }
}
//# sourceMappingURL=loader.js.map