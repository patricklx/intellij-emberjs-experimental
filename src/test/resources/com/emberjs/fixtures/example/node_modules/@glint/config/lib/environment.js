"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GlintEnvironment = exports.DEFAULT_EXTENSIONS = void 0;
const resolve_1 = __importDefault(require("resolve"));
const path_1 = __importDefault(require("path"));
const escape_string_regexp_1 = __importDefault(require("escape-string-regexp"));
const silent_error_1 = __importDefault(require("silent-error"));
exports.DEFAULT_EXTENSIONS = {
    '.hbs': { kind: 'template' },
    '.js': { kind: 'untyped-script' },
    '.ts': { kind: 'typed-script' },
};
class GlintEnvironment {
    constructor(names, config) {
        var _a, _b;
        this.names = names;
        this.tagConfig = (_a = config.tags) !== null && _a !== void 0 ? _a : {};
        this.extensionsConfig = (_b = config.extensions) !== null && _b !== void 0 ? _b : {};
        this.standaloneTemplateConfig = config.template;
        this.tagImportRegexp = this.buildTagImportRegexp();
        this.typedScriptExtensions = this.extensionsOfType('typed-script');
        this.untypedScriptExtensions = this.extensionsOfType('untyped-script');
        this.templateExtensions = this.extensionsOfType('template');
    }
    static load(specifier, { rootDir = '.' } = {}) {
        let envs = normalizeEnvironmentSpecifier(specifier);
        let config = loadMergedEnvironmentConfig(envs, rootDir);
        return new GlintEnvironment(Object.keys(envs), config);
    }
    getSourceKind(fileName) {
        var _a, _b;
        let extension = path_1.default.extname(fileName);
        return (_b = (_a = this.extensionsConfig[extension]) === null || _a === void 0 ? void 0 : _a.kind) !== null && _b !== void 0 ? _b : 'unknown';
    }
    isTypedScript(path) {
        return this.getSourceKind(path) === 'typed-script';
    }
    isUntypedScript(path) {
        return this.getSourceKind(path) === 'untyped-script';
    }
    isScript(path) {
        let kind = this.getSourceKind(path);
        return kind === 'typed-script' || kind === 'untyped-script';
    }
    isTemplate(path) {
        return this.getSourceKind(path) === 'template';
    }
    /**
     * Returns an array of custom file extensions that the active environment
     * is able to handle.
     */
    getConfiguredFileExtensions() {
        return Object.keys(this.extensionsConfig);
    }
    /**
     * Returns any custom configuration for the given file extension.
     */
    getConfigForExtension(extension) {
        return this.extensionsConfig[extension];
    }
    /**
     * Returns the import path that should be used for `@glint/template`-derived
     * types to drive typechecking for standalone template files, if this
     * environment supports such templates.
     */
    getTypesForStandaloneTemplate() {
        var _a;
        return (_a = this.standaloneTemplateConfig) === null || _a === void 0 ? void 0 : _a.typesModule;
    }
    /**
     * Given the path of a script, returns an array of candidate paths where
     * a template corresponding to that script might be located.
     */
    getPossibleTemplatePaths(scriptPath) {
        var _a, _b;
        return normalizePathCandidates((_b = (_a = this.standaloneTemplateConfig) === null || _a === void 0 ? void 0 : _a.getPossibleTemplatePaths(scriptPath)) !== null && _b !== void 0 ? _b : []);
    }
    /**
     * Given the path of a template, returns an array of candidate paths where
     * a script corresponding to that script might be located.
     */
    getPossibleScriptPaths(templatePath) {
        var _a, _b;
        return normalizePathCandidates((_b = (_a = this.standaloneTemplateConfig) === null || _a === void 0 ? void 0 : _a.getPossibleScriptPaths(templatePath)) !== null && _b !== void 0 ? _b : []);
    }
    /**
     * Indicates whether the given module _may_ have embedded templates in it.
     *
     * Note that this method is intended to be a cheaper initial pass to avoid needlessly
     * parsing modules that definitely don't require rewriting. It therefore may produce
     * false positives, but should never give a false negative.
     */
    moduleMayHaveEmbeddedTemplates(modulePath, moduleContents) {
        let config = this.getConfigForExtension(path_1.default.extname(modulePath));
        return Boolean((config === null || config === void 0 ? void 0 : config.preprocess) || (config === null || config === void 0 ? void 0 : config.transform) || this.tagImportRegexp.test(moduleContents));
    }
    /**
     * Returns an array of template tags that should be rewritten according to this
     * config object, along with an import specifier indicating where the template types
     * for each tag can be found.
     */
    getConfiguredTemplateTags() {
        return this.tagConfig;
    }
    buildTagImportRegexp() {
        let importSources = Object.keys(this.tagConfig);
        let regexpSource = importSources.map(escape_string_regexp_1.default).join('|');
        return new RegExp(regexpSource);
    }
    extensionsOfType(kind) {
        return Object.keys(this.extensionsConfig).filter((key) => this.extensionsConfig[key].kind === kind);
    }
}
exports.GlintEnvironment = GlintEnvironment;
function normalizeEnvironmentSpecifier(specifier) {
    if (typeof specifier === 'string') {
        return { [specifier]: null };
    }
    else if (Array.isArray(specifier)) {
        return specifier.reduce((obj, name) => ({ ...obj, [name]: null }), {});
    }
    return specifier;
}
function loadMergedEnvironmentConfig(envs, rootDir) {
    var _a, _b;
    let tags = {};
    let extensions = { ...exports.DEFAULT_EXTENSIONS };
    let template;
    for (let [envName, envUserConfig] of Object.entries(envs)) {
        let envPath = locateEnvironment(envName, rootDir);
        let envModule = require(envPath);
        let envFunction = (_a = envModule === null || envModule === void 0 ? void 0 : envModule.default) !== null && _a !== void 0 ? _a : envModule;
        if (typeof envFunction !== 'function') {
            throw new silent_error_1.default(`The specified environment '${envName}', which was loaded from ${envPath}, ` +
                `does not appear to be a Glint environment package.`);
        }
        let config = envFunction(envUserConfig !== null && envUserConfig !== void 0 ? envUserConfig : {});
        if (config.template) {
            if (template) {
                throw new silent_error_1.default('Multiple configured Glint environments attempted to define behavior for standalone template files.');
            }
            template = config.template;
        }
        if (config.tags) {
            for (let [importSource, specifiers] of Object.entries(config.tags)) {
                (_b = tags[importSource]) !== null && _b !== void 0 ? _b : (tags[importSource] = {});
                for (let [importSpecifier, tagConfig] of Object.entries(specifiers)) {
                    if (importSpecifier in tags[importSource]) {
                        throw new silent_error_1.default('Multiple configured Glint environments attempted to define behavior for the tag `' +
                            importSpecifier +
                            "` in module '" +
                            importSource +
                            "'.");
                    }
                    tags[importSource][importSpecifier] = tagConfig;
                }
            }
        }
        if (config.extensions) {
            for (let [extension, extensionConfig] of Object.entries(config.extensions)) {
                if (extension in extensions) {
                    throw new silent_error_1.default('Multiple configured Glint environments attempted to define handling for the ' +
                        extension +
                        ' file extension.');
                }
                extensions[extension] = extensionConfig;
            }
        }
    }
    return { tags, extensions, template };
}
function locateEnvironment(name, basedir) {
    var _a;
    // Resolve a package name, either shorthand or explicit
    for (let candidate of [`@glint/environment-${name}`, `glint-environment-${name}`, name]) {
        let pkg = tryResolve(`${candidate}/package.json`, basedir);
        if (pkg) {
            let relativePath = (_a = require(pkg)['glint-environment']) !== null && _a !== void 0 ? _a : '.';
            return path_1.default.resolve(path_1.default.dirname(pkg), relativePath);
        }
    }
    // Resolve a path to an explicit file
    let literalPath = tryResolve(name, basedir);
    if (literalPath) {
        return literalPath;
    }
    throw new silent_error_1.default(`Unable to resolve environment '${name}' from ${basedir}`);
}
function normalizePathCandidates(candidates) {
    return candidates.map((candidate) => typeof candidate === 'string' ? { path: candidate, deferTo: [] } : candidate);
}
function tryResolve(name, basedir) {
    try {
        return resolve_1.default.sync(name, { basedir });
    }
    catch (error) {
        if ((error === null || error === void 0 ? void 0 : error.code) === 'MODULE_NOT_FOUND') {
            return null;
        }
        throw error;
    }
}
//# sourceMappingURL=environment.js.map