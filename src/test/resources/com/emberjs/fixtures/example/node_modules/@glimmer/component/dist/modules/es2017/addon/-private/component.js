import { DEBUG } from '@glimmer/env';
import { setOwner } from './owner';
import { isDestroying, isDestroyed } from './destroyables';
// SAFETY: this only holds because we *only* acces this when `DEBUG` is `true`.
// There is not a great way to connect that data in TS at present.
export let ARGS_SET;
if (DEBUG) {
    ARGS_SET = new WeakMap();
}
/**
 * The `Component` class defines an encapsulated UI element that is rendered to
 * the DOM. A component is made up of a template and, optionally, this component
 * object.
 *
 * ## Defining a Component
 *
 * To define a component, subclass `Component` and add your own properties,
 * methods and lifecycle hooks:
 *
 * ```ts
 * import Component from '@glimmer/component';
 *
 * export default class extends Component {
 * }
 * ```
 *
 * ## Lifecycle Hooks
 *
 * Lifecycle hooks allow you to respond to changes to a component, such as when
 * it gets created, rendered, updated or destroyed. To add a lifecycle hook to a
 * component, implement the hook as a method on your component subclass.
 *
 * For example, to be notified when Glimmer has rendered your component so you
 * can attach a legacy jQuery plugin, implement the `didInsertElement()` method:
 *
 * ```ts
 * import Component from '@glimmer/component';
 *
 * export default class extends Component {
 *   didInsertElement() {
 *     $(this.element).pickadate();
 *   }
 * }
 * ```
 *
 * ## Data for Templates
 *
 * `Component`s have two different kinds of data, or state, that can be
 * displayed in templates:
 *
 * 1. Arguments
 * 2. Properties
 *
 * Arguments are data that is passed in to a component from its parent
 * component. For example, if I have a `UserGreeting` component, I can pass it
 * a name and greeting to use:
 *
 * ```hbs
 * <UserGreeting @name="Ricardo" @greeting="Olá" />
 * ```
 *
 * Inside my `UserGreeting` template, I can access the `@name` and `@greeting`
 * arguments that I've been given:
 *
 * ```hbs
 * {{@greeting}}, {{@name}}!
 * ```
 *
 * Arguments are also available inside my component:
 *
 * ```ts
 * console.log(this.args.greeting); // prints "Olá"
 * ```
 *
 * Properties, on the other hand, are internal to the component and declared in
 * the class. You can use properties to store data that you want to show in the
 * template, or pass to another component as an argument.
 *
 * ```ts
 * import Component from '@glimmer/component';
 *
 * export default class extends Component {
 *   user = {
 *     name: 'Robbie'
 *   }
 * }
 * ```
 *
 * In the above example, we've defined a component with a `user` property that
 * contains an object with its own `name` property.
 *
 * We can render that property in our template:
 *
 * ```hbs
 * Hello, {{user.name}}!
 * ```
 *
 * We can also take that property and pass it as an argument to the
 * `UserGreeting` component we defined above:
 *
 * ```hbs
 * <UserGreeting @greeting="Hello" @name={{user.name}} />
 * ```
 *
 * ## Arguments vs. Properties
 *
 * Remember, arguments are data that was given to your component by its parent
 * component, and properties are data your component has defined for itself.
 *
 * You can tell the difference between arguments and properties in templates
 * because arguments always start with an `@` sign (think "A is for arguments"):
 *
 * ```hbs
 * {{@firstName}}
 * ```
 *
 * We know that `@firstName` came from the parent component, not the current
 * component, because it starts with `@` and is therefore an argument.
 *
 * On the other hand, if we see:
 *
 * ```hbs
 * {{name}}
 * ```
 *
 * We know that `name` is a property on the component. If we want to know where
 * the data is coming from, we can go look at our component class to find out.
 *
 * Inside the component itself, arguments always show up inside the component's
 * `args` property. For example, if `{{@firstName}}` is `Tom` in the template,
 * inside the component `this.args.firstName` would also be `Tom`.
 */
export default class BaseComponent {
    /**
     * Constructs a new component and assigns itself the passed properties. You
     * should not construct new components yourself. Instead, Glimmer will
     * instantiate new components automatically as it renders.
     *
     * @param owner
     * @param args
     */
    constructor(owner, args) {
        if (DEBUG && !(owner !== null && typeof owner === 'object' && ARGS_SET.has(args))) {
            throw new Error(`You must pass both the owner and args to super() in your component: ${this.constructor.name}. You can pass them directly, or use ...arguments to pass all arguments through.`);
        }
        this.args = args;
        setOwner(this, owner);
    }
    get isDestroying() {
        return isDestroying(this);
    }
    get isDestroyed() {
        return isDestroyed(this);
    }
    /**
     * Called before the component has been removed from the DOM.
     */
    willDestroy() { }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvY29tcG9uZW50L2FkZG9uLy1wcml2YXRlL2NvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsS0FBSyxFQUFFLE1BQU0sY0FBYyxDQUFDO0FBQ3JDLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxTQUFTLENBQUM7QUFDbkMsT0FBTyxFQUFFLFlBQVksRUFBRSxXQUFXLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQVczRCwrRUFBK0U7QUFDL0Usa0VBQWtFO0FBQ2xFLE1BQU0sQ0FBQyxJQUFJLFFBQW9CLENBQUM7QUFFaEMsSUFBSSxLQUFLLEVBQUU7SUFDVCxRQUFRLEdBQUcsSUFBSSxPQUFPLEVBQWdCLENBQUM7Q0FDeEM7QUEyRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBMEhHO0FBQ0gsTUFBTSxDQUFDLE9BQU8sT0FBTyxhQUFhO0lBQ2hDOzs7Ozs7O09BT0c7SUFDSCxZQUFZLEtBQWMsRUFBRSxJQUFhO1FBQ3ZDLElBQUksS0FBSyxJQUFJLENBQUMsQ0FBQyxLQUFLLEtBQUssSUFBSSxJQUFJLE9BQU8sS0FBSyxLQUFLLFFBQVEsSUFBSSxRQUFRLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUU7WUFDakYsTUFBTSxJQUFJLEtBQUssQ0FDYix1RUFDRSxJQUFJLENBQUMsV0FBVyxDQUFDLElBQ25CLGtGQUFrRixDQUNuRixDQUFDO1NBQ0g7UUFFRCxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztRQUNqQixRQUFRLENBQUMsSUFBSSxFQUFFLEtBQVksQ0FBQyxDQUFDO0lBQy9CLENBQUM7SUE0QkQsSUFBSSxZQUFZO1FBQ2QsT0FBTyxZQUFZLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDNUIsQ0FBQztJQUVELElBQUksV0FBVztRQUNiLE9BQU8sV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzNCLENBQUM7SUFFRDs7T0FFRztJQUNILFdBQVcsS0FBVSxDQUFDO0NBQ3ZCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgREVCVUcgfSBmcm9tICdAZ2xpbW1lci9lbnYnO1xuaW1wb3J0IHsgc2V0T3duZXIgfSBmcm9tICcuL293bmVyJztcbmltcG9ydCB7IGlzRGVzdHJveWluZywgaXNEZXN0cm95ZWQgfSBmcm9tICcuL2Rlc3Ryb3lhYmxlcyc7XG5cbi8vIFRoaXMgcHJvdmlkZXMgYSB0eXBlLXNhZmUgYFdlYWtNYXBgOiB0aGUgZ2V0dGVyIGFuZCBzZXR0ZXIgbGluayB0aGUga2V5IHRvIGFcbi8vIHNwZWNpZmljIHZhbHVlLiBUaGlzIGlzIGhvdyBgV2Vha01hcGBzIGFjdHVhbGx5IGJlaGF2ZSwgYnV0IHRoZSBUUyB0eXBlXG4vLyBzeXN0ZW0gZG9lcyBub3QgKHlldCEpIGhhdmUgYSBnb29kIHdheSB0byBjYXB0dXJlIHRoYXQgZm9yIHR5cGVzIGxpa2Vcbi8vIGBXZWFrTWFwYCB3aGVyZSB0aGUgdHlwZSBpcyBnZW5lcmljIG92ZXIgYW5vdGhlciBnZW5lcmljIHR5cGUgKGhlcmUsIGBBcmdzYCkuXG5pbnRlcmZhY2UgQXJnc1NldE1hcCBleHRlbmRzIFdlYWtNYXA8QXJnczx1bmtub3duPiwgYm9vbGVhbj4ge1xuICBnZXQ8Uz4oa2V5OiBBcmdzPFM+KTogYm9vbGVhbiB8IHVuZGVmaW5lZDtcbiAgc2V0PFM+KGtleTogQXJnczxTPiwgdmFsdWU6IGJvb2xlYW4pOiB0aGlzO1xufVxuXG4vLyBTQUZFVFk6IHRoaXMgb25seSBob2xkcyBiZWNhdXNlIHdlICpvbmx5KiBhY2NlcyB0aGlzIHdoZW4gYERFQlVHYCBpcyBgdHJ1ZWAuXG4vLyBUaGVyZSBpcyBub3QgYSBncmVhdCB3YXkgdG8gY29ubmVjdCB0aGF0IGRhdGEgaW4gVFMgYXQgcHJlc2VudC5cbmV4cG9ydCBsZXQgQVJHU19TRVQ6IEFyZ3NTZXRNYXA7XG5cbmlmIChERUJVRykge1xuICBBUkdTX1NFVCA9IG5ldyBXZWFrTWFwKCkgYXMgQXJnc1NldE1hcDtcbn1cblxuLy8gLS0tIFR5cGUgdXRpbGl0aWVzIGZvciBjb21wb25lbnQgc2lnbmF0dXJlcyAtLS0gLy9cbi8vIFR5cGUtb25seSBcInN5bWJvbFwiIHRvIHVzZSB3aXRoIGBFbXB0eU9iamVjdGAgYmVsb3csIHNvIHRoYXQgaXQgaXMgKm5vdCpcbi8vIGVxdWl2YWxlbnQgdG8gYW4gZW1wdHkgaW50ZXJmYWNlLlxuZGVjbGFyZSBjb25zdCBFbXB0eTogdW5pcXVlIHN5bWJvbDtcblxuLyoqXG4gKiBUaGlzIHByb3ZpZGVzIHVzIGEgd2F5IHRvIGhhdmUgYSBcImZhbGxiYWNrXCIgd2hpY2ggcmVwcmVzZW50cyBhbiBlbXB0eSBvYmplY3QsXG4gKiB3aXRob3V0IHRoZSBkb3duc2lkZXMgb2YgaG93IFRTIHRyZWF0cyBge31gLiBTcGVjaWZpY2FsbHk6IHRoaXMgd2lsbFxuICogY29ycmVjdGx5IGxldmVyYWdlIFwiZXhjZXNzIHByb3BlcnR5IGNoZWNraW5nXCIgc28gdGhhdCwgZ2l2ZW4gYSBjb21wb25lbnRcbiAqIHdoaWNoIGhhcyBubyBuYW1lZCBhcmdzLCBpZiBzb21lb25lIGludm9rZXMgaXQgd2l0aCBhbnkgbmFtZWQgYXJncywgdGhleSB3aWxsXG4gKiBnZXQgYSB0eXBlIGVycm9yLlxuICpcbiAqIEBpbnRlcm5hbCBUaGlzIGlzIGV4cG9ydGVkIHNvIGRlY2xhcmF0aW9uIGVtaXQgd29ya3MgKGlmIGl0IHdlcmUgbm90IGVtaXR0ZWQsXG4gKiAgIGRlY2xhcmF0aW9ucyB3aGljaCBmYWxsIGJhY2sgdG8gaXQgd291bGQgbm90IHdvcmspLiBJdCBpcyAqbm90KiBpbnRlbmRlZCBmb3JcbiAqICAgcHVibGljIHVzYWdlLCBhbmQgdGhlIHNwZWNpZmljIG1lY2hhbmljcyBpdCB1c2VzIG1heSBjaGFuZ2UgYXQgYW55IHRpbWUuXG4gKiAgIFRoZSBsb2NhdGlvbiBvZiB0aGlzIGV4cG9ydCAqaXMqIHBhcnQgb2YgdGhlIHB1YmxpYyBBUEksIGJlY2F1c2UgbW92aW5nIGl0XG4gKiAgIHdpbGwgYnJlYWsgZXhpc3RpbmcgZGVjbGFyYXRpb25zLCBidXQgaXMgbm90IGxlZ2FsIGZvciBlbmQgdXNlcnMgdG8gaW1wb3J0XG4gKiAgIHRoZW1zZWx2ZXMsIHNvICoqKkRPIE5PVCBSRUxZIE9OIElUKioqLlxuICovXG5leHBvcnQgdHlwZSBFbXB0eU9iamVjdCA9IHsgW0VtcHR5XT86IHRydWUgfTtcblxudHlwZSBHZXRPckVsc2U8T2JqLCBLIGV4dGVuZHMgUHJvcGVydHlLZXksIEZhbGxiYWNrPiA9IE9iaiBleHRlbmRzIHsgW0tleSBpbiBLXTogaW5mZXIgVSB9XG4gID8gVVxuICA6IEZhbGxiYWNrO1xuXG4vKiogR2l2ZW4gYSBzaWduYXR1cmUgYFNgLCBnZXQgYmFjayB0aGUgYEFyZ3NgIHR5cGUuICovXG50eXBlIEFyZ3NGb3I8Uz4gPSBTIGV4dGVuZHMgeyBBcmdzOiBpbmZlciBBcmdzIH1cbiAgPyBBcmdzIGV4dGVuZHMgeyBOYW1lZD86IG9iamVjdDsgUG9zaXRpb25hbD86IHVua25vd25bXSB9IC8vIEFyZSB0aGV5IGxvbmdoYW5kIGFscmVhZHk/XG4gICAgPyB7XG4gICAgICAgIE5hbWVkOiBHZXRPckVsc2U8U1snQXJncyddLCAnTmFtZWQnLCBFbXB0eU9iamVjdD47XG4gICAgICAgIFBvc2l0aW9uYWw6IEdldE9yRWxzZTxTWydBcmdzJ10sICdQb3NpdGlvbmFsJywgW10+O1xuICAgICAgfVxuICAgIDogeyBOYW1lZDogU1snQXJncyddOyBQb3NpdGlvbmFsOiBbXSB9XG4gIDogeyBOYW1lZDogRW1wdHlPYmplY3Q7IFBvc2l0aW9uYWw6IFtdIH07XG5cbnR5cGUgX0V4cGFuZFNpZ25hdHVyZTxUPiA9IHtcbiAgRWxlbWVudDogR2V0T3JFbHNlPFQsICdFbGVtZW50JywgbnVsbD47XG4gIEFyZ3M6IGtleW9mIFQgZXh0ZW5kcyAnQXJncycgfCAnRWxlbWVudCcgfCAnQmxvY2tzJyAvLyBJcyB0aGlzIGEgYFNpZ25hdHVyZWA/XG4gICAgPyBBcmdzRm9yPFQ+IC8vIFRoZW4gdXNlIGBTaWduYXR1cmVgIGFyZ3NcbiAgICA6IHsgTmFtZWQ6IFQ7IFBvc2l0aW9uYWw6IFtdIH07IC8vIE90aGVyd2lzZSBmYWxsIGJhY2sgdG8gY2xhc3NpYyBgQXJnc2AuXG4gIEJsb2NrczogVCBleHRlbmRzIHsgQmxvY2tzOiBpbmZlciBCbG9ja3MgfVxuICAgID8ge1xuICAgICAgICBbQmxvY2sgaW4ga2V5b2YgQmxvY2tzXTogQmxvY2tzW0Jsb2NrXSBleHRlbmRzIHVua25vd25bXVxuICAgICAgICAgID8geyBQYXJhbXM6IHsgUG9zaXRpb25hbDogQmxvY2tzW0Jsb2NrXSB9IH1cbiAgICAgICAgICA6IEJsb2Nrc1tCbG9ja107XG4gICAgICB9XG4gICAgOiBFbXB0eU9iamVjdDtcbn07XG5cbi8qKlxuICogR2l2ZW4gYW55IGFsbG93ZWQgc2hvcnRoYW5kIGZvcm0gb2YgYSBzaWduYXR1cmUsIGRlc3VnYXJzIGl0IHRvIGl0cyBmdWxsXG4gKiBleHBhbmRlZCB0eXBlLlxuICpcbiAqIEBpbnRlcm5hbCBUaGlzIGlzIG9ubHkgZXhwb3J0ZWQgc28gd2UgY2FuIGF2b2lkIGR1cGxpY2F0aW5nIGl0IGluXG4gKiAgIFtHbGludF0oaHR0cHM6Ly9naXRodWIuY29tL3R5cGVkLWVtYmVyL2dsaW50KSBvciBvdGhlciBzdWNoIHRvb2xpbmcuIEl0IGlzXG4gKiAgICpub3QqIGludGVuZGVkIGZvciBwdWJsaWMgdXNhZ2UsIGFuZCB0aGUgc3BlY2lmaWMgbWVjaGFuaWNzIGl0IHVzZXMgbWF5XG4gKiAgIGNoYW5nZSBhdCBhbnkgdGltZS4gQWx0aG91Z2ggdGhlIHNpZ25hdHVyZSBwcm9kdWNlZCBieSBpcyBwYXJ0IG9mIEdsaW1tZXInc1xuICogICBwdWJsaWMgQVBJIHRoZSBleGlzdGVuY2UgYW5kIG1lY2hhbmljcyBvZiB0aGlzIHNwZWNpZmljIHN5bWJvbCBhcmUgKm5vdCosXG4gKiAgIHNvICoqKkRPIE5PVCBSRUxZIE9OIElUKioqLlxuICovXG4vLyBUaGUgY29uZGl0aW9uYWwgdHlwZSBoZXJlIGlzIGJlY2F1c2UgVFMgYXBwbGllcyBjb25kaXRpb25hbCB0eXBlc1xuLy8gZGlzdHJpYnV0aXZlbHkuIFRoaXMgbWVhbnMgdGhhdCBmb3IgdW5pb24gdHlwZXMsIGNoZWNrcyBsaWtlIGBrZXlvZiBUYCBnZXRcbi8vIGFsbCB0aGUga2V5cyBmcm9tIGFsbCBlbGVtZW50cyBvZiB0aGUgdW5pb24sIGluc3RlYWQgb2YgZW5kaW5nIHVwIGFzIGBuZXZlcmBcbi8vIGFuZCB0aGVuIGFsd2F5cyBmYWxsaW5nIGludG8gdGhlIGBTaWduYXR1cmVgIHBhdGggaW5zdGVhZCBvZiBmYWxsaW5nIGJhY2sgdG9cbi8vIHRoZSBsZWdhY3kgYXJncyBoYW5kbGluZyBwYXRoLlxuZXhwb3J0IHR5cGUgRXhwYW5kU2lnbmF0dXJlPFQ+ID0gVCBleHRlbmRzIGFueSA/IF9FeHBhbmRTaWduYXR1cmU8VD4gOiBuZXZlcjtcblxuLyoqXG4gKiBAaW50ZXJuYWwgd2UgdXNlIHRoaXMgdHlwZSBmb3IgY29udmVuaWVuY2UgaW50ZXJuYWxseTsgaW5mZXJlbmNlIG1lYW5zIHVzZXJzXG4gKiAgIHNob3VsZCBub3Qgbm9ybWFsbHkgbmVlZCB0byBuYW1lIGl0XG4gKi9cbmV4cG9ydCB0eXBlIEFyZ3M8Uz4gPSBFeHBhbmRTaWduYXR1cmU8Uz5bJ0FyZ3MnXVsnTmFtZWQnXTtcblxuLyoqXG4gKiBUaGUgYENvbXBvbmVudGAgY2xhc3MgZGVmaW5lcyBhbiBlbmNhcHN1bGF0ZWQgVUkgZWxlbWVudCB0aGF0IGlzIHJlbmRlcmVkIHRvXG4gKiB0aGUgRE9NLiBBIGNvbXBvbmVudCBpcyBtYWRlIHVwIG9mIGEgdGVtcGxhdGUgYW5kLCBvcHRpb25hbGx5LCB0aGlzIGNvbXBvbmVudFxuICogb2JqZWN0LlxuICpcbiAqICMjIERlZmluaW5nIGEgQ29tcG9uZW50XG4gKlxuICogVG8gZGVmaW5lIGEgY29tcG9uZW50LCBzdWJjbGFzcyBgQ29tcG9uZW50YCBhbmQgYWRkIHlvdXIgb3duIHByb3BlcnRpZXMsXG4gKiBtZXRob2RzIGFuZCBsaWZlY3ljbGUgaG9va3M6XG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCBDb21wb25lbnQgZnJvbSAnQGdsaW1tZXIvY29tcG9uZW50JztcbiAqXG4gKiBleHBvcnQgZGVmYXVsdCBjbGFzcyBleHRlbmRzIENvbXBvbmVudCB7XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiAjIyBMaWZlY3ljbGUgSG9va3NcbiAqXG4gKiBMaWZlY3ljbGUgaG9va3MgYWxsb3cgeW91IHRvIHJlc3BvbmQgdG8gY2hhbmdlcyB0byBhIGNvbXBvbmVudCwgc3VjaCBhcyB3aGVuXG4gKiBpdCBnZXRzIGNyZWF0ZWQsIHJlbmRlcmVkLCB1cGRhdGVkIG9yIGRlc3Ryb3llZC4gVG8gYWRkIGEgbGlmZWN5Y2xlIGhvb2sgdG8gYVxuICogY29tcG9uZW50LCBpbXBsZW1lbnQgdGhlIGhvb2sgYXMgYSBtZXRob2Qgb24geW91ciBjb21wb25lbnQgc3ViY2xhc3MuXG4gKlxuICogRm9yIGV4YW1wbGUsIHRvIGJlIG5vdGlmaWVkIHdoZW4gR2xpbW1lciBoYXMgcmVuZGVyZWQgeW91ciBjb21wb25lbnQgc28geW91XG4gKiBjYW4gYXR0YWNoIGEgbGVnYWN5IGpRdWVyeSBwbHVnaW4sIGltcGxlbWVudCB0aGUgYGRpZEluc2VydEVsZW1lbnQoKWAgbWV0aG9kOlxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgQ29tcG9uZW50IGZyb20gJ0BnbGltbWVyL2NvbXBvbmVudCc7XG4gKlxuICogZXhwb3J0IGRlZmF1bHQgY2xhc3MgZXh0ZW5kcyBDb21wb25lbnQge1xuICogICBkaWRJbnNlcnRFbGVtZW50KCkge1xuICogICAgICQodGhpcy5lbGVtZW50KS5waWNrYWRhdGUoKTtcbiAqICAgfVxuICogfVxuICogYGBgXG4gKlxuICogIyMgRGF0YSBmb3IgVGVtcGxhdGVzXG4gKlxuICogYENvbXBvbmVudGBzIGhhdmUgdHdvIGRpZmZlcmVudCBraW5kcyBvZiBkYXRhLCBvciBzdGF0ZSwgdGhhdCBjYW4gYmVcbiAqIGRpc3BsYXllZCBpbiB0ZW1wbGF0ZXM6XG4gKlxuICogMS4gQXJndW1lbnRzXG4gKiAyLiBQcm9wZXJ0aWVzXG4gKlxuICogQXJndW1lbnRzIGFyZSBkYXRhIHRoYXQgaXMgcGFzc2VkIGluIHRvIGEgY29tcG9uZW50IGZyb20gaXRzIHBhcmVudFxuICogY29tcG9uZW50LiBGb3IgZXhhbXBsZSwgaWYgSSBoYXZlIGEgYFVzZXJHcmVldGluZ2AgY29tcG9uZW50LCBJIGNhbiBwYXNzIGl0XG4gKiBhIG5hbWUgYW5kIGdyZWV0aW5nIHRvIHVzZTpcbiAqXG4gKiBgYGBoYnNcbiAqIDxVc2VyR3JlZXRpbmcgQG5hbWU9XCJSaWNhcmRvXCIgQGdyZWV0aW5nPVwiT2zDoVwiIC8+XG4gKiBgYGBcbiAqXG4gKiBJbnNpZGUgbXkgYFVzZXJHcmVldGluZ2AgdGVtcGxhdGUsIEkgY2FuIGFjY2VzcyB0aGUgYEBuYW1lYCBhbmQgYEBncmVldGluZ2BcbiAqIGFyZ3VtZW50cyB0aGF0IEkndmUgYmVlbiBnaXZlbjpcbiAqXG4gKiBgYGBoYnNcbiAqIHt7QGdyZWV0aW5nfX0sIHt7QG5hbWV9fSFcbiAqIGBgYFxuICpcbiAqIEFyZ3VtZW50cyBhcmUgYWxzbyBhdmFpbGFibGUgaW5zaWRlIG15IGNvbXBvbmVudDpcbiAqXG4gKiBgYGB0c1xuICogY29uc29sZS5sb2codGhpcy5hcmdzLmdyZWV0aW5nKTsgLy8gcHJpbnRzIFwiT2zDoVwiXG4gKiBgYGBcbiAqXG4gKiBQcm9wZXJ0aWVzLCBvbiB0aGUgb3RoZXIgaGFuZCwgYXJlIGludGVybmFsIHRvIHRoZSBjb21wb25lbnQgYW5kIGRlY2xhcmVkIGluXG4gKiB0aGUgY2xhc3MuIFlvdSBjYW4gdXNlIHByb3BlcnRpZXMgdG8gc3RvcmUgZGF0YSB0aGF0IHlvdSB3YW50IHRvIHNob3cgaW4gdGhlXG4gKiB0ZW1wbGF0ZSwgb3IgcGFzcyB0byBhbm90aGVyIGNvbXBvbmVudCBhcyBhbiBhcmd1bWVudC5cbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IENvbXBvbmVudCBmcm9tICdAZ2xpbW1lci9jb21wb25lbnQnO1xuICpcbiAqIGV4cG9ydCBkZWZhdWx0IGNsYXNzIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAqICAgdXNlciA9IHtcbiAqICAgICBuYW1lOiAnUm9iYmllJ1xuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBJbiB0aGUgYWJvdmUgZXhhbXBsZSwgd2UndmUgZGVmaW5lZCBhIGNvbXBvbmVudCB3aXRoIGEgYHVzZXJgIHByb3BlcnR5IHRoYXRcbiAqIGNvbnRhaW5zIGFuIG9iamVjdCB3aXRoIGl0cyBvd24gYG5hbWVgIHByb3BlcnR5LlxuICpcbiAqIFdlIGNhbiByZW5kZXIgdGhhdCBwcm9wZXJ0eSBpbiBvdXIgdGVtcGxhdGU6XG4gKlxuICogYGBgaGJzXG4gKiBIZWxsbywge3t1c2VyLm5hbWV9fSFcbiAqIGBgYFxuICpcbiAqIFdlIGNhbiBhbHNvIHRha2UgdGhhdCBwcm9wZXJ0eSBhbmQgcGFzcyBpdCBhcyBhbiBhcmd1bWVudCB0byB0aGVcbiAqIGBVc2VyR3JlZXRpbmdgIGNvbXBvbmVudCB3ZSBkZWZpbmVkIGFib3ZlOlxuICpcbiAqIGBgYGhic1xuICogPFVzZXJHcmVldGluZyBAZ3JlZXRpbmc9XCJIZWxsb1wiIEBuYW1lPXt7dXNlci5uYW1lfX0gLz5cbiAqIGBgYFxuICpcbiAqICMjIEFyZ3VtZW50cyB2cy4gUHJvcGVydGllc1xuICpcbiAqIFJlbWVtYmVyLCBhcmd1bWVudHMgYXJlIGRhdGEgdGhhdCB3YXMgZ2l2ZW4gdG8geW91ciBjb21wb25lbnQgYnkgaXRzIHBhcmVudFxuICogY29tcG9uZW50LCBhbmQgcHJvcGVydGllcyBhcmUgZGF0YSB5b3VyIGNvbXBvbmVudCBoYXMgZGVmaW5lZCBmb3IgaXRzZWxmLlxuICpcbiAqIFlvdSBjYW4gdGVsbCB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIGFyZ3VtZW50cyBhbmQgcHJvcGVydGllcyBpbiB0ZW1wbGF0ZXNcbiAqIGJlY2F1c2UgYXJndW1lbnRzIGFsd2F5cyBzdGFydCB3aXRoIGFuIGBAYCBzaWduICh0aGluayBcIkEgaXMgZm9yIGFyZ3VtZW50c1wiKTpcbiAqXG4gKiBgYGBoYnNcbiAqIHt7QGZpcnN0TmFtZX19XG4gKiBgYGBcbiAqXG4gKiBXZSBrbm93IHRoYXQgYEBmaXJzdE5hbWVgIGNhbWUgZnJvbSB0aGUgcGFyZW50IGNvbXBvbmVudCwgbm90IHRoZSBjdXJyZW50XG4gKiBjb21wb25lbnQsIGJlY2F1c2UgaXQgc3RhcnRzIHdpdGggYEBgIGFuZCBpcyB0aGVyZWZvcmUgYW4gYXJndW1lbnQuXG4gKlxuICogT24gdGhlIG90aGVyIGhhbmQsIGlmIHdlIHNlZTpcbiAqXG4gKiBgYGBoYnNcbiAqIHt7bmFtZX19XG4gKiBgYGBcbiAqXG4gKiBXZSBrbm93IHRoYXQgYG5hbWVgIGlzIGEgcHJvcGVydHkgb24gdGhlIGNvbXBvbmVudC4gSWYgd2Ugd2FudCB0byBrbm93IHdoZXJlXG4gKiB0aGUgZGF0YSBpcyBjb21pbmcgZnJvbSwgd2UgY2FuIGdvIGxvb2sgYXQgb3VyIGNvbXBvbmVudCBjbGFzcyB0byBmaW5kIG91dC5cbiAqXG4gKiBJbnNpZGUgdGhlIGNvbXBvbmVudCBpdHNlbGYsIGFyZ3VtZW50cyBhbHdheXMgc2hvdyB1cCBpbnNpZGUgdGhlIGNvbXBvbmVudCdzXG4gKiBgYXJnc2AgcHJvcGVydHkuIEZvciBleGFtcGxlLCBpZiBge3tAZmlyc3ROYW1lfX1gIGlzIGBUb21gIGluIHRoZSB0ZW1wbGF0ZSxcbiAqIGluc2lkZSB0aGUgY29tcG9uZW50IGB0aGlzLmFyZ3MuZmlyc3ROYW1lYCB3b3VsZCBhbHNvIGJlIGBUb21gLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNlQ29tcG9uZW50PFMgPSB1bmtub3duPiB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGNvbXBvbmVudCBhbmQgYXNzaWducyBpdHNlbGYgdGhlIHBhc3NlZCBwcm9wZXJ0aWVzLiBZb3VcbiAgICogc2hvdWxkIG5vdCBjb25zdHJ1Y3QgbmV3IGNvbXBvbmVudHMgeW91cnNlbGYuIEluc3RlYWQsIEdsaW1tZXIgd2lsbFxuICAgKiBpbnN0YW50aWF0ZSBuZXcgY29tcG9uZW50cyBhdXRvbWF0aWNhbGx5IGFzIGl0IHJlbmRlcnMuXG4gICAqXG4gICAqIEBwYXJhbSBvd25lclxuICAgKiBAcGFyYW0gYXJnc1xuICAgKi9cbiAgY29uc3RydWN0b3Iob3duZXI6IHVua25vd24sIGFyZ3M6IEFyZ3M8Uz4pIHtcbiAgICBpZiAoREVCVUcgJiYgIShvd25lciAhPT0gbnVsbCAmJiB0eXBlb2Ygb3duZXIgPT09ICdvYmplY3QnICYmIEFSR1NfU0VULmhhcyhhcmdzKSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFlvdSBtdXN0IHBhc3MgYm90aCB0aGUgb3duZXIgYW5kIGFyZ3MgdG8gc3VwZXIoKSBpbiB5b3VyIGNvbXBvbmVudDogJHtcbiAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLm5hbWVcbiAgICAgICAgfS4gWW91IGNhbiBwYXNzIHRoZW0gZGlyZWN0bHksIG9yIHVzZSAuLi5hcmd1bWVudHMgdG8gcGFzcyBhbGwgYXJndW1lbnRzIHRocm91Z2guYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgIHNldE93bmVyKHRoaXMsIG93bmVyIGFzIGFueSk7XG4gIH1cblxuICAvKipcbiAgICogTmFtZWQgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgY29tcG9uZW50IGZyb20gaXRzIHBhcmVudCBjb21wb25lbnQuXG4gICAqIFRoZXkgY2FuIGJlIGFjY2Vzc2VkIGluIEphdmFTY3JpcHQgdmlhIGB0aGlzLmFyZ3MuYXJndW1lbnROYW1lYCBhbmQgaW4gdGhlIHRlbXBsYXRlIHZpYSBgQGFyZ3VtZW50TmFtZWAuXG4gICAqXG4gICAqIFNheSB5b3UgaGF2ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudCwgd2hpY2ggd2lsbCBoYXZlIHR3byBgYXJnc2AsIGBmaXJzdE5hbWVgIGFuZCBgbGFzdE5hbWVgOlxuICAgKlxuICAgKiBgYGBoYnNcbiAgICogPG15LWNvbXBvbmVudCBAZmlyc3ROYW1lPVwiQXJ0aHVyXCIgQGxhc3ROYW1lPVwiRGVudFwiIC8+XG4gICAqIGBgYFxuICAgKlxuICAgKiBJZiB5b3UgbmVlZGVkIHRvIGNhbGN1bGF0ZSBgZnVsbE5hbWVgIGJ5IGNvbWJpbmluZyBib3RoIG9mIHRoZW0sIHlvdSB3b3VsZCBkbzpcbiAgICpcbiAgICogYGBgdHNcbiAgICogZGlkSW5zZXJ0RWxlbWVudCgpIHtcbiAgICogICBjb25zb2xlLmxvZyhgSGksIG15IGZ1bGwgbmFtZSBpcyAke3RoaXMuYXJncy5maXJzdE5hbWV9ICR7dGhpcy5hcmdzLmxhc3ROYW1lfWApO1xuICAgKiB9XG4gICAqIGBgYFxuICAgKlxuICAgKiBXaGlsZSBpbiB0aGUgdGVtcGxhdGUgeW91IGNvdWxkIGRvOlxuICAgKlxuICAgKiBgYGBoYnNcbiAgICogPHA+V2VsY29tZSwge3tAZmlyc3ROYW1lfX0ge3tAbGFzdE5hbWV9fSE8L3A+XG4gICAqIGBgYFxuICAgKi9cbiAgYXJnczogUmVhZG9ubHk8QXJnczxTPj47XG5cbiAgZ2V0IGlzRGVzdHJveWluZygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gaXNEZXN0cm95aW5nKHRoaXMpO1xuICB9XG5cbiAgZ2V0IGlzRGVzdHJveWVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBpc0Rlc3Ryb3llZCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgYmVmb3JlIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBET00uXG4gICAqL1xuICB3aWxsRGVzdHJveSgpOiB2b2lkIHt9XG59XG4iXX0=