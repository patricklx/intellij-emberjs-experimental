"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const transform_1 = require("@glint/transform");
const util_1 = require("@glint/transform/lib/util");
const document_cache_1 = __importStar(require("./document-cache"));
class TransformManager {
    constructor(glintConfig, documents = new document_cache_1.default(glintConfig)) {
        this.glintConfig = glintConfig;
        this.documents = documents;
        this.transformCache = new Map();
        this.watchTransformedFile = (path, originalCallback, pollingInterval, options) => {
            const { watchFile } = this.ts.sys;
            (0, util_1.assert)(watchFile);
            let { glintConfig, documents } = this;
            let callback = (watchedPath, eventKind) => {
                if (eventKind === this.ts.FileWatcherEventKind.Deleted) {
                    this.documents.removeDocument(watchedPath);
                }
                else {
                    this.documents.markDocumentStale(watchedPath);
                }
                return originalCallback(path, eventKind);
            };
            if (!glintConfig.includesFile(path)) {
                return watchFile(path, callback, pollingInterval, options);
            }
            let allPaths = [
                ...glintConfig.environment.getPossibleTemplatePaths(path).map((candidate) => candidate.path),
                ...documents.getCandidateDocumentPaths(path),
            ];
            let allWatchers = allPaths.map((candidate) => watchFile(candidate, callback, pollingInterval, options));
            return {
                close() {
                    allWatchers.forEach((watcher) => watcher.close());
                },
            };
        };
        this.watchDirectory = (path, originalCallback, recursive, options) => {
            (0, util_1.assert)(this.ts.sys.watchDirectory);
            let callback = (filename) => originalCallback(this.glintConfig.getSynthesizedScriptPathForTS(filename));
            return this.ts.sys.watchDirectory(path, callback, recursive, options);
        };
        this.readDirectory = (rootDir, extensions, excludes, includes, depth) => {
            let env = this.glintConfig.environment;
            let allExtensions = [...new Set([...extensions, ...env.getConfiguredFileExtensions()])];
            return this.ts.sys
                .readDirectory(rootDir, allExtensions, excludes, includes, depth)
                .map((filename) => this.glintConfig.getSynthesizedScriptPathForTS(filename));
        };
        this.fileExists = (filename) => {
            return this.documents.documentExists(filename);
        };
        this.readTransformedFile = (filename, encoding) => {
            let transformInfo = this.getTransformInfo(filename, encoding);
            if (transformInfo === null || transformInfo === void 0 ? void 0 : transformInfo.transformedModule) {
                return transformInfo.transformedModule.transformedContents;
            }
            else {
                return this.documents.getDocumentContents(filename, encoding);
            }
        };
        this.ts = glintConfig.ts;
    }
    getTransformDiagnostics(fileName) {
        var _a;
        if (fileName) {
            let transformedModule = (_a = this.getTransformInfo(fileName)) === null || _a === void 0 ? void 0 : _a.transformedModule;
            return transformedModule ? this.buildTransformDiagnostics(transformedModule) : [];
        }
        return [...this.transformCache.values()].flatMap((transformInfo) => {
            if (transformInfo.transformedModule) {
                return this.buildTransformDiagnostics(transformInfo.transformedModule);
            }
            return [];
        });
    }
    rewriteDiagnostics(diagnostics, fileName) {
        let unusedExpectErrors = new Set(this.getExpectErrorDirectives(fileName));
        let allDiagnostics = [];
        for (let diagnostic of diagnostics) {
            let { rewrittenDiagnostic, appliedDirective } = this.rewriteDiagnostic(diagnostic);
            if (rewrittenDiagnostic) {
                allDiagnostics.push(rewrittenDiagnostic);
            }
            if ((appliedDirective === null || appliedDirective === void 0 ? void 0 : appliedDirective.kind) === 'expect-error') {
                unusedExpectErrors.delete(appliedDirective);
            }
        }
        for (let directive of unusedExpectErrors) {
            allDiagnostics.push((0, transform_1.createTransformDiagnostic)(this.ts, directive.source, `Unused '@glint-expect-error' directive.`, directive.location));
        }
        return this.ts.sortAndDeduplicateDiagnostics(allDiagnostics);
    }
    getTransformedRange(originalFileName, originalStart, originalEnd) {
        let transformInfo = this.findTransformInfoForOriginalFile(originalFileName);
        if (!(transformInfo === null || transformInfo === void 0 ? void 0 : transformInfo.transformedModule)) {
            return {
                transformedFileName: originalFileName,
                transformedStart: originalStart,
                transformedEnd: originalEnd,
            };
        }
        let { transformedFileName, transformedModule } = transformInfo;
        let transformedRange = transformedModule.getTransformedRange(originalFileName, originalStart, originalEnd);
        return {
            transformedFileName,
            transformedStart: transformedRange.start,
            transformedEnd: transformedRange.end,
        };
    }
    getOriginalRange(transformedFileName, transformedStart, transformedEnd) {
        let transformInfo = this.getTransformInfo(transformedFileName);
        let { documents } = this;
        if (!(transformInfo === null || transformInfo === void 0 ? void 0 : transformInfo.transformedModule)) {
            return {
                originalFileName: documents.getCanonicalDocumentPath(transformedFileName),
                originalStart: transformedStart,
                originalEnd: transformedEnd,
            };
        }
        let original = transformInfo.transformedModule.getOriginalRange(transformedStart, transformedEnd);
        return {
            originalFileName: documents.getCanonicalDocumentPath(original.source.filename),
            originalStart: Math.max(original.start, 0),
            originalEnd: original.end,
        };
    }
    getTransformedOffset(originalFileName, originalOffset) {
        let transformInfo = this.findTransformInfoForOriginalFile(originalFileName);
        if (!(transformInfo === null || transformInfo === void 0 ? void 0 : transformInfo.transformedModule)) {
            return { transformedFileName: originalFileName, transformedOffset: originalOffset };
        }
        let { transformedFileName, transformedModule } = transformInfo;
        let transformedOffset = transformedModule.getTransformedOffset(originalFileName, originalOffset);
        return { transformedFileName, transformedOffset };
    }
    getExpectErrorDirectives(filename) {
        let transformInfos = filename
            ? [this.getTransformInfo(filename)]
            : [...this.transformCache.values()];
        return transformInfos.flatMap((transformInfo) => {
            if (!transformInfo.transformedModule)
                return [];
            return transformInfo.transformedModule.directives.filter((directive) => directive.kind === 'expect-error');
        });
    }
    rewriteDiagnostic(diagnostic) {
        var _a, _b;
        if (!diagnostic.file)
            return {};
        // Transform diagnostics are already targeted at the original source and so
        // don't need to be rewritten.
        if ('isGlintTransformDiagnostic' in diagnostic && diagnostic.isGlintTransformDiagnostic) {
            return { rewrittenDiagnostic: diagnostic };
        }
        let transformInfo = this.getTransformInfo((_a = diagnostic.file) === null || _a === void 0 ? void 0 : _a.fileName);
        let rewrittenDiagnostic = (0, transform_1.rewriteDiagnostic)(this.ts, diagnostic, (fileName) => { var _a; return (_a = this.getTransformInfo(fileName)) === null || _a === void 0 ? void 0 : _a.transformedModule; });
        if (rewrittenDiagnostic.file) {
            rewrittenDiagnostic.file.fileName = this.documents.getCanonicalDocumentPath(rewrittenDiagnostic.file.fileName);
        }
        let appliedDirective = (_b = transformInfo.transformedModule) === null || _b === void 0 ? void 0 : _b.directives.find((directive) => {
            var _a;
            return directive.source.filename === ((_a = rewrittenDiagnostic.file) === null || _a === void 0 ? void 0 : _a.fileName) &&
                directive.areaOfEffect.start <= rewrittenDiagnostic.start &&
                directive.areaOfEffect.end > rewrittenDiagnostic.start;
        });
        // All current directives have the effect of squashing any diagnostics they apply
        // to, so if we have an applicable directive, we don't return the diagnostic.
        if (appliedDirective) {
            return { appliedDirective };
        }
        else {
            return { rewrittenDiagnostic };
        }
    }
    findTransformInfoForOriginalFile(originalFileName) {
        let transformedFileName = this.glintConfig.environment.isTemplate(originalFileName)
            ? this.documents.getCompanionDocumentPath(originalFileName)
            : originalFileName;
        return transformedFileName ? this.getTransformInfo(transformedFileName) : null;
    }
    getTransformInfo(filename, encoding) {
        let { documents, glintConfig } = this;
        let { environment } = glintConfig;
        let documentID = documents.getDocumentID(filename);
        let existing = this.transformCache.get(documentID);
        let version = documents.getCompoundDocumentVersion(filename);
        if ((existing === null || existing === void 0 ? void 0 : existing.version) === version) {
            return existing;
        }
        let transformedModule = null;
        if (environment.isScript(filename) && glintConfig.includesFile(filename)) {
            if (documents.documentExists(filename)) {
                let contents = documents.getDocumentContents(filename, encoding);
                let templatePath = documents.getCompanionDocumentPath(filename);
                let canonicalPath = documents.getCanonicalDocumentPath(filename);
                let mayHaveEmbeds = environment.moduleMayHaveEmbeddedTemplates(canonicalPath, contents);
                if (mayHaveEmbeds || templatePath) {
                    let script = { filename: canonicalPath, contents };
                    let template = templatePath
                        ? {
                            filename: templatePath,
                            contents: documents.getDocumentContents(templatePath, encoding),
                        }
                        : undefined;
                    transformedModule = (0, transform_1.rewriteModule)(this.ts, { script, template }, environment);
                }
            }
            else {
                let templatePath = (0, document_cache_1.templatePathForSynthesizedModule)(filename);
                if (documents.documentExists(templatePath) &&
                    documents.getCompanionDocumentPath(templatePath) === filename) {
                    // The script we were asked for doesn't exist, but a corresponding template does, and
                    // it doesn't have a companion script elsewhere.
                    let script = { filename, contents: '' };
                    let template = {
                        filename: templatePath,
                        contents: documents.getDocumentContents(templatePath, encoding),
                    };
                    transformedModule = (0, transform_1.rewriteModule)(this.ts, { script, template }, glintConfig.environment);
                }
            }
        }
        let transformedFileName = glintConfig.getSynthesizedScriptPathForTS(filename);
        let cacheEntry = { version, transformedFileName, transformedModule };
        this.transformCache.set(documentID, cacheEntry);
        return cacheEntry;
    }
    buildTransformDiagnostics(transformedModule) {
        return transformedModule.errors.map((error) => (0, transform_1.createTransformDiagnostic)(this.ts, error.source, error.message, error.location));
    }
}
exports.default = TransformManager;
//# sourceMappingURL=transform-manager.js.map
