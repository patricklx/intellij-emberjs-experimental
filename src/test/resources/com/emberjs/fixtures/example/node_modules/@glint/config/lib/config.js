"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizePath = exports.GlintConfig = void 0;
const path_1 = __importDefault(require("path"));
const minimatch_1 = require("minimatch");
const environment_1 = require("./environment");
/**
 * This class represents parsed Glint configuration from a `tsconfig` or `jsconfig` file,
 * with methods for interrogating project configuration based on its contents.
 */
class GlintConfig {
    constructor(ts, configPath, config) {
        var _a, _b, _c;
        Object.defineProperty(this, 'ts', { value: ts });
        this.configPath = normalizePath(configPath);
        this.rootDir = path_1.default.dirname(configPath);
        this.environment = environment_1.GlintEnvironment.load(config.environment, { rootDir: this.rootDir });
        this.checkStandaloneTemplates = (_a = config.checkStandaloneTemplates) !== null && _a !== void 0 ? _a : true;
        let extensions = this.environment.getConfiguredFileExtensions();
        let transform = (_b = config.transform) !== null && _b !== void 0 ? _b : {};
        let include = Array.isArray(transform.include)
            ? transform.include
            : transform.include
                ? [transform.include]
                : extensions.map((ext) => `**/*${ext}`);
        let exclude = Array.isArray(transform.exclude)
            ? transform.exclude
            : [(_c = transform.exclude) !== null && _c !== void 0 ? _c : '**/node_modules/**'];
        this.includeMatchers = this.buildMatchers(include);
        this.excludeMatchers = this.buildMatchers(exclude);
    }
    /**
     * Indicates whether this configuration object applies to the file at the
     * given path.
     */
    includesFile(rawFileName) {
        let fileName = normalizePath(rawFileName);
        return (this.excludeMatchers.every((matcher) => !matcher.match(fileName)) &&
            this.includeMatchers.some((matcher) => matcher.match(fileName)));
    }
    // Given the path of a template or script (potentially with a custom extension),
    // returns the corresponding .js or .ts path we present to the TS language service.
    getSynthesizedScriptPathForTS(filename) {
        let extension = path_1.default.extname(filename);
        let filenameWithoutExtension = filename.slice(0, filename.lastIndexOf(extension));
        switch (this.environment.getSourceKind(filename)) {
            case 'template':
                return `${filenameWithoutExtension}${this.checkStandaloneTemplates ? '.ts' : '.js'}`;
            case 'typed-script':
                return `${filenameWithoutExtension}.ts`;
            case 'untyped-script':
                return `${filenameWithoutExtension}.js`;
            default:
                return filename;
        }
    }
    buildMatchers(globs) {
        return globs.map((glob) => new minimatch_1.Minimatch(normalizePath(path_1.default.resolve(this.rootDir, glob))));
    }
}
exports.GlintConfig = GlintConfig;
function normalizePath(fileName) {
    if (path_1.default.sep !== '/') {
        return fileName.split(path_1.default.sep).join('/');
    }
    return fileName;
}
exports.normalizePath = normalizePath;
//# sourceMappingURL=config.js.map