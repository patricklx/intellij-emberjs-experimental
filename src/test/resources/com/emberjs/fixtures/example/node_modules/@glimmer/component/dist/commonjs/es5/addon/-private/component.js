"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.ARGS_SET = undefined;

var _env = require("@glimmer/env");

var _owner = require("./owner");

var _destroyables = require("./destroyables");

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

// SAFETY: this only holds because we *only* acces this when `DEBUG` is `true`.
// There is not a great way to connect that data in TS at present.
var ARGS_SET = exports.ARGS_SET = undefined;

if (_env.DEBUG) {
  exports.ARGS_SET = ARGS_SET = new WeakMap();
}
/**
 * The `Component` class defines an encapsulated UI element that is rendered to
 * the DOM. A component is made up of a template and, optionally, this component
 * object.
 *
 * ## Defining a Component
 *
 * To define a component, subclass `Component` and add your own properties,
 * methods and lifecycle hooks:
 *
 * ```ts
 * import Component from '@glimmer/component';
 *
 * export default class extends Component {
 * }
 * ```
 *
 * ## Lifecycle Hooks
 *
 * Lifecycle hooks allow you to respond to changes to a component, such as when
 * it gets created, rendered, updated or destroyed. To add a lifecycle hook to a
 * component, implement the hook as a method on your component subclass.
 *
 * For example, to be notified when Glimmer has rendered your component so you
 * can attach a legacy jQuery plugin, implement the `didInsertElement()` method:
 *
 * ```ts
 * import Component from '@glimmer/component';
 *
 * export default class extends Component {
 *   didInsertElement() {
 *     $(this.element).pickadate();
 *   }
 * }
 * ```
 *
 * ## Data for Templates
 *
 * `Component`s have two different kinds of data, or state, that can be
 * displayed in templates:
 *
 * 1. Arguments
 * 2. Properties
 *
 * Arguments are data that is passed in to a component from its parent
 * component. For example, if I have a `UserGreeting` component, I can pass it
 * a name and greeting to use:
 *
 * ```hbs
 * <UserGreeting @name="Ricardo" @greeting="Olá" />
 * ```
 *
 * Inside my `UserGreeting` template, I can access the `@name` and `@greeting`
 * arguments that I've been given:
 *
 * ```hbs
 * {{@greeting}}, {{@name}}!
 * ```
 *
 * Arguments are also available inside my component:
 *
 * ```ts
 * console.log(this.args.greeting); // prints "Olá"
 * ```
 *
 * Properties, on the other hand, are internal to the component and declared in
 * the class. You can use properties to store data that you want to show in the
 * template, or pass to another component as an argument.
 *
 * ```ts
 * import Component from '@glimmer/component';
 *
 * export default class extends Component {
 *   user = {
 *     name: 'Robbie'
 *   }
 * }
 * ```
 *
 * In the above example, we've defined a component with a `user` property that
 * contains an object with its own `name` property.
 *
 * We can render that property in our template:
 *
 * ```hbs
 * Hello, {{user.name}}!
 * ```
 *
 * We can also take that property and pass it as an argument to the
 * `UserGreeting` component we defined above:
 *
 * ```hbs
 * <UserGreeting @greeting="Hello" @name={{user.name}} />
 * ```
 *
 * ## Arguments vs. Properties
 *
 * Remember, arguments are data that was given to your component by its parent
 * component, and properties are data your component has defined for itself.
 *
 * You can tell the difference between arguments and properties in templates
 * because arguments always start with an `@` sign (think "A is for arguments"):
 *
 * ```hbs
 * {{@firstName}}
 * ```
 *
 * We know that `@firstName` came from the parent component, not the current
 * component, because it starts with `@` and is therefore an argument.
 *
 * On the other hand, if we see:
 *
 * ```hbs
 * {{name}}
 * ```
 *
 * We know that `name` is a property on the component. If we want to know where
 * the data is coming from, we can go look at our component class to find out.
 *
 * Inside the component itself, arguments always show up inside the component's
 * `args` property. For example, if `{{@firstName}}` is `Tom` in the template,
 * inside the component `this.args.firstName` would also be `Tom`.
 */


var BaseComponent =
/*#__PURE__*/
function () {
  /**
   * Constructs a new component and assigns itself the passed properties. You
   * should not construct new components yourself. Instead, Glimmer will
   * instantiate new components automatically as it renders.
   *
   * @param owner
   * @param args
   */
  function BaseComponent(owner, args) {
    if (_env.DEBUG && !(owner !== null && typeof owner === 'object' && ARGS_SET.has(args))) {
      throw new Error("You must pass both the owner and args to super() in your component: " + this.constructor.name + ". You can pass them directly, or use ...arguments to pass all arguments through.");
    }

    this.args = args;
    (0, _owner.setOwner)(this, owner);
  }

  var _proto = BaseComponent.prototype;
  /**
   * Called before the component has been removed from the DOM.
   */

  _proto.willDestroy = function willDestroy() {};

  _createClass(BaseComponent, [{
    key: "isDestroying",
    get: function get() {
      return (0, _destroyables.isDestroying)(this);
    }
  }, {
    key: "isDestroyed",
    get: function get() {
      return (0, _destroyables.isDestroyed)(this);
    }
  }]);

  return BaseComponent;
}();

exports.default = BaseComponent;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL2NvbXBvbmVudC9hZGRvbi8tcHJpdmF0ZS9jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUNBOztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ08sSUFBSSxRQUFKLFdBQUksUUFBSixZQUFBOztBQUVQLElBQUEsVUFBQSxFQUFXO0FBQ1QsVUFIUyxRQUdULEdBQUEsUUFBUSxHQUFHLElBQVgsT0FBVyxFQUFYO0FBQ0Q7QUEyRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBMkhxQixhOzs7QUFDbkI7Ozs7Ozs7O0FBUUEsV0FBQSxhQUFBLENBQUEsS0FBQSxFQUFBLElBQUEsRUFBeUM7QUFDdkMsUUFBSSxjQUFTLEVBQUUsS0FBSyxLQUFMLElBQUEsSUFBa0IsT0FBQSxLQUFBLEtBQWxCLFFBQUEsSUFBK0MsUUFBUSxDQUFSLEdBQUEsQ0FBOUQsSUFBOEQsQ0FBakQsQ0FBYixFQUFtRjtBQUNqRixZQUFNLElBQUEsS0FBQSxDQUFBLHlFQUVGLEtBQUEsV0FBQSxDQUZFLElBQUEsR0FBTixrRkFBTSxDQUFOO0FBS0Q7O0FBRUQsU0FBQSxJQUFBLEdBQUEsSUFBQTtBQUNBLHlCQUFRLElBQVIsRUFBQSxLQUFBO0FBQ0Q7OztBQW9DRDs7OztTQUdBLFcsR0FBQSxTQUFBLFdBQUEsR0FBVyxDOzs7O3dCQVhLO0FBQ2QsYUFBTyxnQ0FBUCxJQUFPLENBQVA7QUFDRDs7O3dCQUVjO0FBQ2IsYUFBTywrQkFBUCxJQUFPLENBQVA7QUFDRDs7Ozs7O2tCQXREa0IsYSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERFQlVHIH0gZnJvbSAnQGdsaW1tZXIvZW52JztcbmltcG9ydCB7IHNldE93bmVyIH0gZnJvbSAnLi9vd25lcic7XG5pbXBvcnQgeyBpc0Rlc3Ryb3lpbmcsIGlzRGVzdHJveWVkIH0gZnJvbSAnLi9kZXN0cm95YWJsZXMnO1xuXG4vLyBUaGlzIHByb3ZpZGVzIGEgdHlwZS1zYWZlIGBXZWFrTWFwYDogdGhlIGdldHRlciBhbmQgc2V0dGVyIGxpbmsgdGhlIGtleSB0byBhXG4vLyBzcGVjaWZpYyB2YWx1ZS4gVGhpcyBpcyBob3cgYFdlYWtNYXBgcyBhY3R1YWxseSBiZWhhdmUsIGJ1dCB0aGUgVFMgdHlwZVxuLy8gc3lzdGVtIGRvZXMgbm90ICh5ZXQhKSBoYXZlIGEgZ29vZCB3YXkgdG8gY2FwdHVyZSB0aGF0IGZvciB0eXBlcyBsaWtlXG4vLyBgV2Vha01hcGAgd2hlcmUgdGhlIHR5cGUgaXMgZ2VuZXJpYyBvdmVyIGFub3RoZXIgZ2VuZXJpYyB0eXBlIChoZXJlLCBgQXJnc2ApLlxuaW50ZXJmYWNlIEFyZ3NTZXRNYXAgZXh0ZW5kcyBXZWFrTWFwPEFyZ3M8dW5rbm93bj4sIGJvb2xlYW4+IHtcbiAgZ2V0PFM+KGtleTogQXJnczxTPik6IGJvb2xlYW4gfCB1bmRlZmluZWQ7XG4gIHNldDxTPihrZXk6IEFyZ3M8Uz4sIHZhbHVlOiBib29sZWFuKTogdGhpcztcbn1cblxuLy8gU0FGRVRZOiB0aGlzIG9ubHkgaG9sZHMgYmVjYXVzZSB3ZSAqb25seSogYWNjZXMgdGhpcyB3aGVuIGBERUJVR2AgaXMgYHRydWVgLlxuLy8gVGhlcmUgaXMgbm90IGEgZ3JlYXQgd2F5IHRvIGNvbm5lY3QgdGhhdCBkYXRhIGluIFRTIGF0IHByZXNlbnQuXG5leHBvcnQgbGV0IEFSR1NfU0VUOiBBcmdzU2V0TWFwO1xuXG5pZiAoREVCVUcpIHtcbiAgQVJHU19TRVQgPSBuZXcgV2Vha01hcCgpIGFzIEFyZ3NTZXRNYXA7XG59XG5cbi8vIC0tLSBUeXBlIHV0aWxpdGllcyBmb3IgY29tcG9uZW50IHNpZ25hdHVyZXMgLS0tIC8vXG4vLyBUeXBlLW9ubHkgXCJzeW1ib2xcIiB0byB1c2Ugd2l0aCBgRW1wdHlPYmplY3RgIGJlbG93LCBzbyB0aGF0IGl0IGlzICpub3QqXG4vLyBlcXVpdmFsZW50IHRvIGFuIGVtcHR5IGludGVyZmFjZS5cbmRlY2xhcmUgY29uc3QgRW1wdHk6IHVuaXF1ZSBzeW1ib2w7XG5cbi8qKlxuICogVGhpcyBwcm92aWRlcyB1cyBhIHdheSB0byBoYXZlIGEgXCJmYWxsYmFja1wiIHdoaWNoIHJlcHJlc2VudHMgYW4gZW1wdHkgb2JqZWN0LFxuICogd2l0aG91dCB0aGUgZG93bnNpZGVzIG9mIGhvdyBUUyB0cmVhdHMgYHt9YC4gU3BlY2lmaWNhbGx5OiB0aGlzIHdpbGxcbiAqIGNvcnJlY3RseSBsZXZlcmFnZSBcImV4Y2VzcyBwcm9wZXJ0eSBjaGVja2luZ1wiIHNvIHRoYXQsIGdpdmVuIGEgY29tcG9uZW50XG4gKiB3aGljaCBoYXMgbm8gbmFtZWQgYXJncywgaWYgc29tZW9uZSBpbnZva2VzIGl0IHdpdGggYW55IG5hbWVkIGFyZ3MsIHRoZXkgd2lsbFxuICogZ2V0IGEgdHlwZSBlcnJvci5cbiAqXG4gKiBAaW50ZXJuYWwgVGhpcyBpcyBleHBvcnRlZCBzbyBkZWNsYXJhdGlvbiBlbWl0IHdvcmtzIChpZiBpdCB3ZXJlIG5vdCBlbWl0dGVkLFxuICogICBkZWNsYXJhdGlvbnMgd2hpY2ggZmFsbCBiYWNrIHRvIGl0IHdvdWxkIG5vdCB3b3JrKS4gSXQgaXMgKm5vdCogaW50ZW5kZWQgZm9yXG4gKiAgIHB1YmxpYyB1c2FnZSwgYW5kIHRoZSBzcGVjaWZpYyBtZWNoYW5pY3MgaXQgdXNlcyBtYXkgY2hhbmdlIGF0IGFueSB0aW1lLlxuICogICBUaGUgbG9jYXRpb24gb2YgdGhpcyBleHBvcnQgKmlzKiBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJLCBiZWNhdXNlIG1vdmluZyBpdFxuICogICB3aWxsIGJyZWFrIGV4aXN0aW5nIGRlY2xhcmF0aW9ucywgYnV0IGlzIG5vdCBsZWdhbCBmb3IgZW5kIHVzZXJzIHRvIGltcG9ydFxuICogICB0aGVtc2VsdmVzLCBzbyAqKipETyBOT1QgUkVMWSBPTiBJVCoqKi5cbiAqL1xuZXhwb3J0IHR5cGUgRW1wdHlPYmplY3QgPSB7IFtFbXB0eV0/OiB0cnVlIH07XG5cbnR5cGUgR2V0T3JFbHNlPE9iaiwgSyBleHRlbmRzIFByb3BlcnR5S2V5LCBGYWxsYmFjaz4gPSBPYmogZXh0ZW5kcyB7IFtLZXkgaW4gS106IGluZmVyIFUgfVxuICA/IFVcbiAgOiBGYWxsYmFjaztcblxuLyoqIEdpdmVuIGEgc2lnbmF0dXJlIGBTYCwgZ2V0IGJhY2sgdGhlIGBBcmdzYCB0eXBlLiAqL1xudHlwZSBBcmdzRm9yPFM+ID0gUyBleHRlbmRzIHsgQXJnczogaW5mZXIgQXJncyB9XG4gID8gQXJncyBleHRlbmRzIHsgTmFtZWQ/OiBvYmplY3Q7IFBvc2l0aW9uYWw/OiB1bmtub3duW10gfSAvLyBBcmUgdGhleSBsb25naGFuZCBhbHJlYWR5P1xuICAgID8ge1xuICAgICAgICBOYW1lZDogR2V0T3JFbHNlPFNbJ0FyZ3MnXSwgJ05hbWVkJywgRW1wdHlPYmplY3Q+O1xuICAgICAgICBQb3NpdGlvbmFsOiBHZXRPckVsc2U8U1snQXJncyddLCAnUG9zaXRpb25hbCcsIFtdPjtcbiAgICAgIH1cbiAgICA6IHsgTmFtZWQ6IFNbJ0FyZ3MnXTsgUG9zaXRpb25hbDogW10gfVxuICA6IHsgTmFtZWQ6IEVtcHR5T2JqZWN0OyBQb3NpdGlvbmFsOiBbXSB9O1xuXG50eXBlIF9FeHBhbmRTaWduYXR1cmU8VD4gPSB7XG4gIEVsZW1lbnQ6IEdldE9yRWxzZTxULCAnRWxlbWVudCcsIG51bGw+O1xuICBBcmdzOiBrZXlvZiBUIGV4dGVuZHMgJ0FyZ3MnIHwgJ0VsZW1lbnQnIHwgJ0Jsb2NrcycgLy8gSXMgdGhpcyBhIGBTaWduYXR1cmVgP1xuICAgID8gQXJnc0ZvcjxUPiAvLyBUaGVuIHVzZSBgU2lnbmF0dXJlYCBhcmdzXG4gICAgOiB7IE5hbWVkOiBUOyBQb3NpdGlvbmFsOiBbXSB9OyAvLyBPdGhlcndpc2UgZmFsbCBiYWNrIHRvIGNsYXNzaWMgYEFyZ3NgLlxuICBCbG9ja3M6IFQgZXh0ZW5kcyB7IEJsb2NrczogaW5mZXIgQmxvY2tzIH1cbiAgICA/IHtcbiAgICAgICAgW0Jsb2NrIGluIGtleW9mIEJsb2Nrc106IEJsb2Nrc1tCbG9ja10gZXh0ZW5kcyB1bmtub3duW11cbiAgICAgICAgICA/IHsgUGFyYW1zOiB7IFBvc2l0aW9uYWw6IEJsb2Nrc1tCbG9ja10gfSB9XG4gICAgICAgICAgOiBCbG9ja3NbQmxvY2tdO1xuICAgICAgfVxuICAgIDogRW1wdHlPYmplY3Q7XG59O1xuXG4vKipcbiAqIEdpdmVuIGFueSBhbGxvd2VkIHNob3J0aGFuZCBmb3JtIG9mIGEgc2lnbmF0dXJlLCBkZXN1Z2FycyBpdCB0byBpdHMgZnVsbFxuICogZXhwYW5kZWQgdHlwZS5cbiAqXG4gKiBAaW50ZXJuYWwgVGhpcyBpcyBvbmx5IGV4cG9ydGVkIHNvIHdlIGNhbiBhdm9pZCBkdXBsaWNhdGluZyBpdCBpblxuICogICBbR2xpbnRdKGh0dHBzOi8vZ2l0aHViLmNvbS90eXBlZC1lbWJlci9nbGludCkgb3Igb3RoZXIgc3VjaCB0b29saW5nLiBJdCBpc1xuICogICAqbm90KiBpbnRlbmRlZCBmb3IgcHVibGljIHVzYWdlLCBhbmQgdGhlIHNwZWNpZmljIG1lY2hhbmljcyBpdCB1c2VzIG1heVxuICogICBjaGFuZ2UgYXQgYW55IHRpbWUuIEFsdGhvdWdoIHRoZSBzaWduYXR1cmUgcHJvZHVjZWQgYnkgaXMgcGFydCBvZiBHbGltbWVyJ3NcbiAqICAgcHVibGljIEFQSSB0aGUgZXhpc3RlbmNlIGFuZCBtZWNoYW5pY3Mgb2YgdGhpcyBzcGVjaWZpYyBzeW1ib2wgYXJlICpub3QqLFxuICogICBzbyAqKipETyBOT1QgUkVMWSBPTiBJVCoqKi5cbiAqL1xuLy8gVGhlIGNvbmRpdGlvbmFsIHR5cGUgaGVyZSBpcyBiZWNhdXNlIFRTIGFwcGxpZXMgY29uZGl0aW9uYWwgdHlwZXNcbi8vIGRpc3RyaWJ1dGl2ZWx5LiBUaGlzIG1lYW5zIHRoYXQgZm9yIHVuaW9uIHR5cGVzLCBjaGVja3MgbGlrZSBga2V5b2YgVGAgZ2V0XG4vLyBhbGwgdGhlIGtleXMgZnJvbSBhbGwgZWxlbWVudHMgb2YgdGhlIHVuaW9uLCBpbnN0ZWFkIG9mIGVuZGluZyB1cCBhcyBgbmV2ZXJgXG4vLyBhbmQgdGhlbiBhbHdheXMgZmFsbGluZyBpbnRvIHRoZSBgU2lnbmF0dXJlYCBwYXRoIGluc3RlYWQgb2YgZmFsbGluZyBiYWNrIHRvXG4vLyB0aGUgbGVnYWN5IGFyZ3MgaGFuZGxpbmcgcGF0aC5cbmV4cG9ydCB0eXBlIEV4cGFuZFNpZ25hdHVyZTxUPiA9IFQgZXh0ZW5kcyBhbnkgPyBfRXhwYW5kU2lnbmF0dXJlPFQ+IDogbmV2ZXI7XG5cbi8qKlxuICogQGludGVybmFsIHdlIHVzZSB0aGlzIHR5cGUgZm9yIGNvbnZlbmllbmNlIGludGVybmFsbHk7IGluZmVyZW5jZSBtZWFucyB1c2Vyc1xuICogICBzaG91bGQgbm90IG5vcm1hbGx5IG5lZWQgdG8gbmFtZSBpdFxuICovXG5leHBvcnQgdHlwZSBBcmdzPFM+ID0gRXhwYW5kU2lnbmF0dXJlPFM+WydBcmdzJ11bJ05hbWVkJ107XG5cbi8qKlxuICogVGhlIGBDb21wb25lbnRgIGNsYXNzIGRlZmluZXMgYW4gZW5jYXBzdWxhdGVkIFVJIGVsZW1lbnQgdGhhdCBpcyByZW5kZXJlZCB0b1xuICogdGhlIERPTS4gQSBjb21wb25lbnQgaXMgbWFkZSB1cCBvZiBhIHRlbXBsYXRlIGFuZCwgb3B0aW9uYWxseSwgdGhpcyBjb21wb25lbnRcbiAqIG9iamVjdC5cbiAqXG4gKiAjIyBEZWZpbmluZyBhIENvbXBvbmVudFxuICpcbiAqIFRvIGRlZmluZSBhIGNvbXBvbmVudCwgc3ViY2xhc3MgYENvbXBvbmVudGAgYW5kIGFkZCB5b3VyIG93biBwcm9wZXJ0aWVzLFxuICogbWV0aG9kcyBhbmQgbGlmZWN5Y2xlIGhvb2tzOlxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgQ29tcG9uZW50IGZyb20gJ0BnbGltbWVyL2NvbXBvbmVudCc7XG4gKlxuICogZXhwb3J0IGRlZmF1bHQgY2xhc3MgZXh0ZW5kcyBDb21wb25lbnQge1xuICogfVxuICogYGBgXG4gKlxuICogIyMgTGlmZWN5Y2xlIEhvb2tzXG4gKlxuICogTGlmZWN5Y2xlIGhvb2tzIGFsbG93IHlvdSB0byByZXNwb25kIHRvIGNoYW5nZXMgdG8gYSBjb21wb25lbnQsIHN1Y2ggYXMgd2hlblxuICogaXQgZ2V0cyBjcmVhdGVkLCByZW5kZXJlZCwgdXBkYXRlZCBvciBkZXN0cm95ZWQuIFRvIGFkZCBhIGxpZmVjeWNsZSBob29rIHRvIGFcbiAqIGNvbXBvbmVudCwgaW1wbGVtZW50IHRoZSBob29rIGFzIGEgbWV0aG9kIG9uIHlvdXIgY29tcG9uZW50IHN1YmNsYXNzLlxuICpcbiAqIEZvciBleGFtcGxlLCB0byBiZSBub3RpZmllZCB3aGVuIEdsaW1tZXIgaGFzIHJlbmRlcmVkIHlvdXIgY29tcG9uZW50IHNvIHlvdVxuICogY2FuIGF0dGFjaCBhIGxlZ2FjeSBqUXVlcnkgcGx1Z2luLCBpbXBsZW1lbnQgdGhlIGBkaWRJbnNlcnRFbGVtZW50KClgIG1ldGhvZDpcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IENvbXBvbmVudCBmcm9tICdAZ2xpbW1lci9jb21wb25lbnQnO1xuICpcbiAqIGV4cG9ydCBkZWZhdWx0IGNsYXNzIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAqICAgZGlkSW5zZXJ0RWxlbWVudCgpIHtcbiAqICAgICAkKHRoaXMuZWxlbWVudCkucGlja2FkYXRlKCk7XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqICMjIERhdGEgZm9yIFRlbXBsYXRlc1xuICpcbiAqIGBDb21wb25lbnRgcyBoYXZlIHR3byBkaWZmZXJlbnQga2luZHMgb2YgZGF0YSwgb3Igc3RhdGUsIHRoYXQgY2FuIGJlXG4gKiBkaXNwbGF5ZWQgaW4gdGVtcGxhdGVzOlxuICpcbiAqIDEuIEFyZ3VtZW50c1xuICogMi4gUHJvcGVydGllc1xuICpcbiAqIEFyZ3VtZW50cyBhcmUgZGF0YSB0aGF0IGlzIHBhc3NlZCBpbiB0byBhIGNvbXBvbmVudCBmcm9tIGl0cyBwYXJlbnRcbiAqIGNvbXBvbmVudC4gRm9yIGV4YW1wbGUsIGlmIEkgaGF2ZSBhIGBVc2VyR3JlZXRpbmdgIGNvbXBvbmVudCwgSSBjYW4gcGFzcyBpdFxuICogYSBuYW1lIGFuZCBncmVldGluZyB0byB1c2U6XG4gKlxuICogYGBgaGJzXG4gKiA8VXNlckdyZWV0aW5nIEBuYW1lPVwiUmljYXJkb1wiIEBncmVldGluZz1cIk9sw6FcIiAvPlxuICogYGBgXG4gKlxuICogSW5zaWRlIG15IGBVc2VyR3JlZXRpbmdgIHRlbXBsYXRlLCBJIGNhbiBhY2Nlc3MgdGhlIGBAbmFtZWAgYW5kIGBAZ3JlZXRpbmdgXG4gKiBhcmd1bWVudHMgdGhhdCBJJ3ZlIGJlZW4gZ2l2ZW46XG4gKlxuICogYGBgaGJzXG4gKiB7e0BncmVldGluZ319LCB7e0BuYW1lfX0hXG4gKiBgYGBcbiAqXG4gKiBBcmd1bWVudHMgYXJlIGFsc28gYXZhaWxhYmxlIGluc2lkZSBteSBjb21wb25lbnQ6XG4gKlxuICogYGBgdHNcbiAqIGNvbnNvbGUubG9nKHRoaXMuYXJncy5ncmVldGluZyk7IC8vIHByaW50cyBcIk9sw6FcIlxuICogYGBgXG4gKlxuICogUHJvcGVydGllcywgb24gdGhlIG90aGVyIGhhbmQsIGFyZSBpbnRlcm5hbCB0byB0aGUgY29tcG9uZW50IGFuZCBkZWNsYXJlZCBpblxuICogdGhlIGNsYXNzLiBZb3UgY2FuIHVzZSBwcm9wZXJ0aWVzIHRvIHN0b3JlIGRhdGEgdGhhdCB5b3Ugd2FudCB0byBzaG93IGluIHRoZVxuICogdGVtcGxhdGUsIG9yIHBhc3MgdG8gYW5vdGhlciBjb21wb25lbnQgYXMgYW4gYXJndW1lbnQuXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCBDb21wb25lbnQgZnJvbSAnQGdsaW1tZXIvY29tcG9uZW50JztcbiAqXG4gKiBleHBvcnQgZGVmYXVsdCBjbGFzcyBleHRlbmRzIENvbXBvbmVudCB7XG4gKiAgIHVzZXIgPSB7XG4gKiAgICAgbmFtZTogJ1JvYmJpZSdcbiAqICAgfVxuICogfVxuICogYGBgXG4gKlxuICogSW4gdGhlIGFib3ZlIGV4YW1wbGUsIHdlJ3ZlIGRlZmluZWQgYSBjb21wb25lbnQgd2l0aCBhIGB1c2VyYCBwcm9wZXJ0eSB0aGF0XG4gKiBjb250YWlucyBhbiBvYmplY3Qgd2l0aCBpdHMgb3duIGBuYW1lYCBwcm9wZXJ0eS5cbiAqXG4gKiBXZSBjYW4gcmVuZGVyIHRoYXQgcHJvcGVydHkgaW4gb3VyIHRlbXBsYXRlOlxuICpcbiAqIGBgYGhic1xuICogSGVsbG8sIHt7dXNlci5uYW1lfX0hXG4gKiBgYGBcbiAqXG4gKiBXZSBjYW4gYWxzbyB0YWtlIHRoYXQgcHJvcGVydHkgYW5kIHBhc3MgaXQgYXMgYW4gYXJndW1lbnQgdG8gdGhlXG4gKiBgVXNlckdyZWV0aW5nYCBjb21wb25lbnQgd2UgZGVmaW5lZCBhYm92ZTpcbiAqXG4gKiBgYGBoYnNcbiAqIDxVc2VyR3JlZXRpbmcgQGdyZWV0aW5nPVwiSGVsbG9cIiBAbmFtZT17e3VzZXIubmFtZX19IC8+XG4gKiBgYGBcbiAqXG4gKiAjIyBBcmd1bWVudHMgdnMuIFByb3BlcnRpZXNcbiAqXG4gKiBSZW1lbWJlciwgYXJndW1lbnRzIGFyZSBkYXRhIHRoYXQgd2FzIGdpdmVuIHRvIHlvdXIgY29tcG9uZW50IGJ5IGl0cyBwYXJlbnRcbiAqIGNvbXBvbmVudCwgYW5kIHByb3BlcnRpZXMgYXJlIGRhdGEgeW91ciBjb21wb25lbnQgaGFzIGRlZmluZWQgZm9yIGl0c2VsZi5cbiAqXG4gKiBZb3UgY2FuIHRlbGwgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBhcmd1bWVudHMgYW5kIHByb3BlcnRpZXMgaW4gdGVtcGxhdGVzXG4gKiBiZWNhdXNlIGFyZ3VtZW50cyBhbHdheXMgc3RhcnQgd2l0aCBhbiBgQGAgc2lnbiAodGhpbmsgXCJBIGlzIGZvciBhcmd1bWVudHNcIik6XG4gKlxuICogYGBgaGJzXG4gKiB7e0BmaXJzdE5hbWV9fVxuICogYGBgXG4gKlxuICogV2Uga25vdyB0aGF0IGBAZmlyc3ROYW1lYCBjYW1lIGZyb20gdGhlIHBhcmVudCBjb21wb25lbnQsIG5vdCB0aGUgY3VycmVudFxuICogY29tcG9uZW50LCBiZWNhdXNlIGl0IHN0YXJ0cyB3aXRoIGBAYCBhbmQgaXMgdGhlcmVmb3JlIGFuIGFyZ3VtZW50LlxuICpcbiAqIE9uIHRoZSBvdGhlciBoYW5kLCBpZiB3ZSBzZWU6XG4gKlxuICogYGBgaGJzXG4gKiB7e25hbWV9fVxuICogYGBgXG4gKlxuICogV2Uga25vdyB0aGF0IGBuYW1lYCBpcyBhIHByb3BlcnR5IG9uIHRoZSBjb21wb25lbnQuIElmIHdlIHdhbnQgdG8ga25vdyB3aGVyZVxuICogdGhlIGRhdGEgaXMgY29taW5nIGZyb20sIHdlIGNhbiBnbyBsb29rIGF0IG91ciBjb21wb25lbnQgY2xhc3MgdG8gZmluZCBvdXQuXG4gKlxuICogSW5zaWRlIHRoZSBjb21wb25lbnQgaXRzZWxmLCBhcmd1bWVudHMgYWx3YXlzIHNob3cgdXAgaW5zaWRlIHRoZSBjb21wb25lbnQnc1xuICogYGFyZ3NgIHByb3BlcnR5LiBGb3IgZXhhbXBsZSwgaWYgYHt7QGZpcnN0TmFtZX19YCBpcyBgVG9tYCBpbiB0aGUgdGVtcGxhdGUsXG4gKiBpbnNpZGUgdGhlIGNvbXBvbmVudCBgdGhpcy5hcmdzLmZpcnN0TmFtZWAgd291bGQgYWxzbyBiZSBgVG9tYC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzZUNvbXBvbmVudDxTID0gdW5rbm93bj4ge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBjb21wb25lbnQgYW5kIGFzc2lnbnMgaXRzZWxmIHRoZSBwYXNzZWQgcHJvcGVydGllcy4gWW91XG4gICAqIHNob3VsZCBub3QgY29uc3RydWN0IG5ldyBjb21wb25lbnRzIHlvdXJzZWxmLiBJbnN0ZWFkLCBHbGltbWVyIHdpbGxcbiAgICogaW5zdGFudGlhdGUgbmV3IGNvbXBvbmVudHMgYXV0b21hdGljYWxseSBhcyBpdCByZW5kZXJzLlxuICAgKlxuICAgKiBAcGFyYW0gb3duZXJcbiAgICogQHBhcmFtIGFyZ3NcbiAgICovXG4gIGNvbnN0cnVjdG9yKG93bmVyOiB1bmtub3duLCBhcmdzOiBBcmdzPFM+KSB7XG4gICAgaWYgKERFQlVHICYmICEob3duZXIgIT09IG51bGwgJiYgdHlwZW9mIG93bmVyID09PSAnb2JqZWN0JyAmJiBBUkdTX1NFVC5oYXMoYXJncykpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBZb3UgbXVzdCBwYXNzIGJvdGggdGhlIG93bmVyIGFuZCBhcmdzIHRvIHN1cGVyKCkgaW4geW91ciBjb21wb25lbnQ6ICR7XG4gICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lXG4gICAgICAgIH0uIFlvdSBjYW4gcGFzcyB0aGVtIGRpcmVjdGx5LCBvciB1c2UgLi4uYXJndW1lbnRzIHRvIHBhc3MgYWxsIGFyZ3VtZW50cyB0aHJvdWdoLmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy5hcmdzID0gYXJncztcbiAgICBzZXRPd25lcih0aGlzLCBvd25lciBhcyBhbnkpO1xuICB9XG5cbiAgLyoqXG4gICAqIE5hbWVkIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGNvbXBvbmVudCBmcm9tIGl0cyBwYXJlbnQgY29tcG9uZW50LlxuICAgKiBUaGV5IGNhbiBiZSBhY2Nlc3NlZCBpbiBKYXZhU2NyaXB0IHZpYSBgdGhpcy5hcmdzLmFyZ3VtZW50TmFtZWAgYW5kIGluIHRoZSB0ZW1wbGF0ZSB2aWEgYEBhcmd1bWVudE5hbWVgLlxuICAgKlxuICAgKiBTYXkgeW91IGhhdmUgdGhlIGZvbGxvd2luZyBjb21wb25lbnQsIHdoaWNoIHdpbGwgaGF2ZSB0d28gYGFyZ3NgLCBgZmlyc3ROYW1lYCBhbmQgYGxhc3ROYW1lYDpcbiAgICpcbiAgICogYGBgaGJzXG4gICAqIDxteS1jb21wb25lbnQgQGZpcnN0TmFtZT1cIkFydGh1clwiIEBsYXN0TmFtZT1cIkRlbnRcIiAvPlxuICAgKiBgYGBcbiAgICpcbiAgICogSWYgeW91IG5lZWRlZCB0byBjYWxjdWxhdGUgYGZ1bGxOYW1lYCBieSBjb21iaW5pbmcgYm90aCBvZiB0aGVtLCB5b3Ugd291bGQgZG86XG4gICAqXG4gICAqIGBgYHRzXG4gICAqIGRpZEluc2VydEVsZW1lbnQoKSB7XG4gICAqICAgY29uc29sZS5sb2coYEhpLCBteSBmdWxsIG5hbWUgaXMgJHt0aGlzLmFyZ3MuZmlyc3ROYW1lfSAke3RoaXMuYXJncy5sYXN0TmFtZX1gKTtcbiAgICogfVxuICAgKiBgYGBcbiAgICpcbiAgICogV2hpbGUgaW4gdGhlIHRlbXBsYXRlIHlvdSBjb3VsZCBkbzpcbiAgICpcbiAgICogYGBgaGJzXG4gICAqIDxwPldlbGNvbWUsIHt7QGZpcnN0TmFtZX19IHt7QGxhc3ROYW1lfX0hPC9wPlxuICAgKiBgYGBcbiAgICovXG4gIGFyZ3M6IFJlYWRvbmx5PEFyZ3M8Uz4+O1xuXG4gIGdldCBpc0Rlc3Ryb3lpbmcoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGlzRGVzdHJveWluZyh0aGlzKTtcbiAgfVxuXG4gIGdldCBpc0Rlc3Ryb3llZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gaXNEZXN0cm95ZWQodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIGJlZm9yZSB0aGUgY29tcG9uZW50IGhhcyBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgRE9NLlxuICAgKi9cbiAgd2lsbERlc3Ryb3koKTogdm9pZCB7fVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==