import type ts from 'typescript';
declare type TSLib = typeof ts;
export declare const DEFAULT_EXTENSIONS: GlintExtensionsConfig;
export declare type GlintEnvironmentConfig = {
    tags?: GlintTagsConfig;
    template?: GlintTemplateConfig;
    extensions?: GlintExtensionsConfig;
};
export declare type GlintExtensionPreprocess<T> = (source: string, filePath: string) => {
    contents: string;
    data?: T;
};
export declare type GlintEmitMetadata = {
    prepend?: string;
    append?: string;
    templateLocation?: {
        start: number;
        end: number;
    };
};
export declare type GlintExtensionTransform<T> = (data: T, state: {
    ts: TSLib;
    context: ts.TransformationContext;
    setEmitMetadata: (node: ts.TaggedTemplateExpression, meta: GlintEmitMetadata) => void;
}) => ts.Transformer<ts.Node>;
export declare type SourceKind = 'typed-script' | 'untyped-script' | 'template';
export declare type GlintExtensionConfig<PreprocessData = any> = {
    kind: SourceKind;
    preprocess?: GlintExtensionPreprocess<PreprocessData>;
    transform?: GlintExtensionTransform<PreprocessData>;
};
export declare type GlintExtensionsConfig = {
    [extension: string]: GlintExtensionConfig;
};
export declare type GlintTagConfig = {
    typesModule: string;
    globals?: Array<string>;
};
export declare type GlintTagsConfig = {
    [importSource: string]: {
        [importSpecifier: string]: GlintTagConfig;
    };
};
export declare type PathCandidate = string | PathCandidateWithDeferral;
export declare type PathCandidateWithDeferral = {
    /** The path to be considered. */
    path: string;
    /** Other paths which, if present, should be preferred to this one. */
    deferTo: Array<string>;
};
export declare type GlintTemplateConfig = {
    typesModule: string;
    getPossibleTemplatePaths(scriptPath: string): Array<PathCandidate>;
    getPossibleScriptPaths(templatePath: string): Array<PathCandidate>;
};
export declare class GlintEnvironment {
    readonly names: Array<string>;
    private tagConfig;
    private extensionsConfig;
    private standaloneTemplateConfig;
    private tagImportRegexp;
    typedScriptExtensions: ReadonlyArray<string>;
    untypedScriptExtensions: ReadonlyArray<string>;
    templateExtensions: ReadonlyArray<string>;
    constructor(names: Array<string>, config: GlintEnvironmentConfig);
    static load(specifier: string | Array<string> | Record<string, unknown>, { rootDir }?: {
        rootDir?: string | undefined;
    }): GlintEnvironment;
    getSourceKind(fileName: string): SourceKind | 'unknown';
    isTypedScript(path: string): boolean;
    isUntypedScript(path: string): boolean;
    isScript(path: string): boolean;
    isTemplate(path: string): boolean;
    /**
     * Returns an array of custom file extensions that the active environment
     * is able to handle.
     */
    getConfiguredFileExtensions(): Array<string>;
    /**
     * Returns any custom configuration for the given file extension.
     */
    getConfigForExtension(extension: string): GlintExtensionConfig | undefined;
    /**
     * Returns the import path that should be used for `@glint/template`-derived
     * types to drive typechecking for standalone template files, if this
     * environment supports such templates.
     */
    getTypesForStandaloneTemplate(): string | undefined;
    /**
     * Given the path of a script, returns an array of candidate paths where
     * a template corresponding to that script might be located.
     */
    getPossibleTemplatePaths(scriptPath: string): Array<PathCandidateWithDeferral>;
    /**
     * Given the path of a template, returns an array of candidate paths where
     * a script corresponding to that script might be located.
     */
    getPossibleScriptPaths(templatePath: string): Array<PathCandidateWithDeferral>;
    /**
     * Indicates whether the given module _may_ have embedded templates in it.
     *
     * Note that this method is intended to be a cheaper initial pass to avoid needlessly
     * parsing modules that definitely don't require rewriting. It therefore may produce
     * false positives, but should never give a false negative.
     */
    moduleMayHaveEmbeddedTemplates(modulePath: string, moduleContents: string): boolean;
    /**
     * Returns an array of template tags that should be rewritten according to this
     * config object, along with an import specifier indicating where the template types
     * for each tag can be found.
     */
    getConfiguredTemplateTags(): GlintTagsConfig;
    private buildTagImportRegexp;
    private extensionsOfType;
}
export {};
